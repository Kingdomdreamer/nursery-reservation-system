# 緊急対応実装指示書 - React Error #418 & API 404エラー解決

## 📋 対応概要

**対象システム**: LINE予約システム（ベジライス）  
**対応日時**: 2025年8月5日  
**対応者**: Kiro AI Assistant  
**緊急度**: 最高（本番環境でサービス停止状態）

### 発生していた問題
1. **React Minified Error #418**: JSXにオブジェクトが直接レンダリングされる
2. **API 404エラー**: `/api/admin/preset-products/{presetId}` が本番環境で404
3. **商品選択UI不具合**: 「現在選択できません」の常時表示

## 🎯 実装した解決策

### 1. React Error #418 完全対策

#### 対象ファイル: `src/components/features/reservation/ProductSelectionSection.tsx`

#### 実装内容

**A. 安全なレンダリング関数の直接実装**
```typescript
// 緊急対応: React Error #418 完全回避のための安全なレンダリング関数
const safeRender = (value: unknown): string => {
  if (value === null || value === undefined) return '';
  if (typeof value === 'string') return value;
  if (typeof value === 'number') return String(value);
  if (typeof value === 'boolean') return value ? 'true' : 'false';
  if (typeof value === 'object') {
    try {
      return JSON.stringify(value);
    } catch {
      return '[Object]';
    }
  }
  return String(value);
};

const safeProductName = (product: unknown): string => {
  if (!product || typeof product !== 'object') return '商品名不明';
  const productObj = product as Record<string, unknown>;
  if (typeof productObj.name === 'string') return productObj.name;
  if (typeof productObj.product_name === 'string') return productObj.product_name;
  return '商品名不明';
};

const safePrice = (price: unknown): string => {
  if (typeof price === 'number' && !isNaN(price)) {
    return `¥${price.toLocaleString()}`;
  }
  if (typeof price === 'string') {
    const numPrice = parseFloat(price);
    if (!isNaN(numPrice)) {
      return `¥${numPrice.toLocaleString()}`;
    }
  }
  return '¥0';
};

const safeQuantity = (quantity: unknown): number => {
  if (typeof quantity === 'number' && !isNaN(quantity)) {
    return Math.max(0, Math.floor(quantity));
  }
  if (typeof quantity === 'string') {
    const numQuantity = parseInt(quantity, 10);
    if (!isNaN(numQuantity)) {
      return Math.max(0, numQuantity);
    }
  }
  return 0;
};

const isValidProduct = (product: unknown): product is {
  id: number;
  name: string;
  price: number;
} => {
  return (
    typeof product === 'object' &&
    product !== null &&
    typeof (product as any).id === 'number' &&
    typeof (product as any).name === 'string' &&
    typeof (product as any).price === 'number'
  );
};
```

**B. 完全なエラー境界コンポーネント**
```typescript
// 緊急対応: 完全なエラー境界コンポーネント
class ProductSelectionErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean; error?: Error; errorInfo?: React.ErrorInfo }
> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error) {
    console.error('ProductSelection Error Boundary - getDerivedStateFromError:', error);
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('ProductSelection Error Boundary caught an error:', {
      error: error.message,
      stack: error.stack,
      errorInfo: errorInfo.componentStack
    });
    
    this.setState({ 
      hasError: true, 
      error, 
      errorInfo 
    });
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4">
          <div className="flex items-start">
            <div className="flex-shrink-0">
              <svg className="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
              </svg>
            </div>
            <div className="ml-3">
              <h3 className="text-sm font-medium text-red-800">
                商品選択でエラーが発生しました
              </h3>
              <p className="text-sm text-red-700 mt-1">
                {this.state.error?.message || '予期しないエラーが発生しました'}
              </p>
              <div className="mt-3 space-x-2">
                <button
                  onClick={() => {
                    this.setState({ hasError: false, error: undefined, errorInfo: undefined });
                  }}
                  className="text-sm bg-red-600 text-white px-3 py-1 rounded hover:bg-red-700"
                >
                  再試行
                </button>
                <button
                  onClick={() => {
                    window.location.reload();
                  }}
                  className="text-sm bg-gray-600 text-white px-3 py-1 rounded hover:bg-gray-700"
                >
                  ページを再読み込み
                </button>
              </div>
              
              {/* デバッグ情報（開発環境のみ） */}
              {process.env.NODE_ENV === 'development' && this.state.errorInfo && (
                <details className="mt-3">
                  <summary className="text-xs text-red-600 cursor-pointer">
                    エラー詳細を表示
                  </summary>
                  <pre className="text-xs text-red-600 mt-2 bg-red-100 p-2 rounded overflow-auto max-h-32">
                    {this.state.error?.stack}
                    {'\n\nComponent Stack:'}
                    {this.state.errorInfo.componentStack}
                  </pre>
                </details>
              )}
            </div>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}
```

**C. 商品データの安全な処理ロジック**
```typescript
// 商品データの安全な処理
const safeProducts = useMemo(() => {
  if (!isClient) {
    console.log('[ProductSelection] Client not ready');
    return [];
  }
  
  console.log('[ProductSelection] Processing products:', {
    type: typeof products,
    isArray: Array.isArray(products),
    length: products?.length || 0,
    data: products
  });
  
  // 緊急対応: 商品データが取得できない場合の詳細なエラーハンドリング
  try {
    if (!products) {
      console.error('[ProductSelection] Products is null or undefined');
      setError('商品データが取得できませんでした。ページを再読み込みしてください。');
      return [];
    }
    
    if (!Array.isArray(products)) {
      console.error('[ProductSelection] Products is not an array:', typeof products, products);
      setError('商品データの形式が正しくありません。管理者にお問い合わせください。');
      return [];
    }
    
    if (products.length === 0) {
      console.warn('[ProductSelection] Products array is empty');
      setError('このプリセットには商品が設定されていません。管理画面で商品を追加してください。');
      return [];
    }
    
    // 商品データの検証とフィルタリング
    const validProducts = products.filter((product, index) => {
      try {
        if (!product) {
          console.warn(`[ProductSelection] Product at index ${index} is null/undefined`);
          return false;
        }
        
        if (!isValidProduct(product)) {
          console.warn(`[ProductSelection] Invalid product at index ${index}:`, product);
          return false;
        }
        
        return true;
      } catch (filterError) {
        console.error(`[ProductSelection] Error filtering product at index ${index}:`, filterError);
        return false;
      }
    });
    
    if (validProducts.length === 0) {
      console.error('[ProductSelection] No valid products found after filtering');
      setError('有効な商品データが見つかりませんでした。管理者にお問い合わせください。');
      return [];
    }
    
    console.log(`[ProductSelection] Processed ${validProducts.length} valid products`);
    setError(null);
    return validProducts;
    
  } catch (processingError) {
    console.error('[ProductSelection] Error processing products:', processingError);
    setError('商品データの処理中にエラーが発生しました。ページを再読み込みしてください。');
    return [];
  }
}, [products, isClient]);
```

**D. 全てのJSX表示箇所での安全なレンダリング**
```typescript
// 選択済み商品表示
{selectedProducts.map((product) => (
  <div key={product.product_id} className="flex justify-between items-center text-sm">
    <span>
      {safeRender(product.product_name)} × {safeRender(product.quantity)}
    </span>
    <div className="flex items-center space-x-2">
      {formSettings?.show_price && (
        <span className="font-medium">
          {safePrice(product.total_price)}
        </span>
      )}
      {/* ... */}
    </div>
  </div>
))}

// 商品一覧表示
<h4 className="font-medium text-gray-900">
  {safeRender(product.name)}
</h4>
{formSettings?.show_price && (
  <p className="text-sm text-gray-600">
    {safePrice(product.price)}
  </p>
)}

// エラーメッセージ表示
{errors.products && (
  <div className="mt-4 bg-red-50 border border-red-200 rounded-lg p-3">
    <p className="text-sm text-red-600">{safeRender(errors.products.message)}</p>
  </div>
)}
```

### 2. API 404エラー対策

#### 対象ファイル: `src/app/api/admin/preset-products/[presetId]/route.ts`

#### 実装内容

**A. Next.js 15対応の動的ルートパラメータ処理**
```typescript
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ presetId: string }> }
) {
  try {
    // パラメータの安全な取得
    const { presetId } = await params;
    const id = Number(presetId);
    
    // バリデーション
    if (Number.isNaN(id) || id < 1) {
      console.error(`Invalid presetId: ${presetId}`);
      return NextResponse.json(
        { 
          error: '無効なプリセットIDです',
          code: 'INVALID_PRESET_ID',
          presetId 
        },
        { status: 400 }
      );
    }

    // Supabase接続確認
    if (!supabaseAdmin) {
      console.error('Supabase admin client not available');
      return NextResponse.json(
        { 
          error: 'データベース接続エラー',
          code: 'DB_CONNECTION_ERROR' 
        },
        { status: 500 }
      );
    }

    console.log(`Fetching preset products for presetId: ${id}`);

    // プリセット商品データの取得
    const { data: presetProducts, error: dbError } = await supabaseAdmin
      .from('preset_products')
      .select(`
        product_id,
        display_order,
        is_active,
        product:products(
          id,
          name,
          price,
          category_id,
          visible,
          created_at,
          updated_at
        )
      `)
      .eq('preset_id', id)
      .eq('is_active', true)
      .order('display_order');

    if (dbError) {
      console.error('Database query error:', dbError);
      return NextResponse.json(
        { 
          error: 'データベースクエリエラー',
          code: 'DB_QUERY_ERROR',
          details: dbError.message 
        },
        { status: 500 }
      );
    }

    // データの整形と検証
    const validProducts = (presetProducts || [])
      .filter(pp => {
        // 商品データの存在確認
        if (!pp.product || typeof pp.product !== 'object') {
          console.warn(`Product not found for product_id: ${pp.product_id}`);
          return false;
        }
        
        // 配列の場合は最初の要素を使用
        const product = Array.isArray(pp.product) ? pp.product[0] : pp.product;
        
        if (!product) {
          console.warn(`Product data is empty for product_id: ${pp.product_id}`);
          return false;
        }
        
        // 商品の可視性確認
        if (product.visible === false) {
          console.warn(`Product not visible: ${product.id}`);
          return false;
        }
        
        return true;
      })
      .map(pp => {
        const product = Array.isArray(pp.product) ? pp.product[0] : pp.product;
        return {
          ...product,
          display_order: pp.display_order,
          preset_product_id: pp.product_id
        };
      })
      .sort((a, b) => (a.display_order || 999) - (b.display_order || 999));

    console.log(`Found ${validProducts.length} valid products for preset ${id}`);

    return NextResponse.json({
      success: true,
      data: validProducts,
      meta: {
        presetId: id,
        totalCount: validProducts.length,
        timestamp: new Date().toISOString()
      }
    });

  } catch (error) {
    console.error('Unexpected error in preset-products API:', error);
    return NextResponse.json(
      { 
        error: '予期しないエラーが発生しました',
        code: 'UNEXPECTED_ERROR',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
```

### 3. データ取得フック強化

#### 対象ファイル: `src/hooks/useFormConfig.ts`

#### 実装内容

**A. 詳細なログ出力とリトライ機能**
```typescript
const fetchConfig = useCallback(async (attempt = 0) => {
  if (!enabled || presetId < 1) {
    setLoading(false);
    return;
  }

  try {
    setLoading(true);
    setError(null);
    
    const startTime = Date.now();
    console.log(`[useFormConfig] Fetching config for preset: ${presetId} (attempt ${attempt + 1})`);
    
    // API呼び出し
    const response = await fetch(`/api/form/${presetId}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': 'no-cache',
      },
    });
    
    const endTime = Date.now();
    const responseTime = endTime - startTime;
    
    console.log(`[useFormConfig] API response:`, {
      status: response.status,
      statusText: response.statusText,
      responseTime: `${responseTime}ms`,
      headers: Object.fromEntries(response.headers.entries())
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`[useFormConfig] API error response:`, {
        status: response.status,
        statusText: response.statusText,
        body: errorText
      });
      
      throw new Error(`API error: ${response.status} ${response.statusText}`);
    }
    
    const result = await response.json();
    
    console.log(`[useFormConfig] API result:`, {
      success: result.success,
      hasData: !!result.data,
      productsCount: result.data?.products?.length || 0,
      formSettingsExists: !!result.data?.form_settings,
      presetExists: !!result.data?.preset
    });
    
    if (!result.success || !result.data) {
      throw new Error('フォーム設定の読み込みに失敗しました');
    }
    
    // デバッグ情報の更新
    setDebugInfo({
      presetId,
      responseTime,
      attempt: attempt + 1,
      timestamp: new Date().toISOString(),
      apiResponse: {
        success: result.success,
        dataKeys: result.data ? Object.keys(result.data) : [],
        productsCount: result.data?.products?.length || 0
      }
    });
    
    setConfig(result.data);
    setRetryAttempt(0);
    
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : 'エラーが発生しました';
    console.error(`[useFormConfig] Fetch error (attempt ${attempt + 1}):`, err);
    
    // リトライロジック
    if (attempt < retryCount - 1) {
      console.log(`[useFormConfig] Retrying in ${retryDelay}ms...`);
      setRetryAttempt(attempt + 1);
      
      setTimeout(() => {
        fetchConfig(attempt + 1);
      }, retryDelay * (attempt + 1)); // 指数バックオフ
      
      return;
    }
    
    // 最終的なエラー処理
    setError(errorMessage);
    setDebugInfo({
      presetId,
      error: errorMessage,
      attempt: attempt + 1,
      timestamp: new Date().toISOString(),
      finalAttempt: true
    });
    
    onError?.(errorMessage);
  } finally {
    if (attempt === retryCount - 1 || !error) {
      setLoading(false);
    }
  }
}, [presetId, enabled, onError, retryCount, retryDelay]);
```

## 🔍 実装手順（他のAI向け指示）

### Step 1: ProductSelectionSection.tsx の修正

1. **ファイルを開く**: `src/components/features/reservation/ProductSelectionSection.tsx`

2. **インポート文の修正**:
   ```typescript
   // 既存のインポート文の後に、安全なレンダリング関数を直接実装
   ```

3. **安全なレンダリング関数の追加**:
   - `safeRender`関数を実装
   - `safeProductName`関数を実装
   - `safePrice`関数を実装
   - `safeQuantity`関数を実装
   - `isValidProduct`型ガード関数を実装

4. **エラー境界コンポーネントの追加**:
   - `ProductSelectionErrorBoundary`クラスコンポーネントを実装
   - エラー時のUI表示を含む

5. **商品データ処理ロジックの修正**:
   - `safeProducts`のuseMemoを詳細なエラーハンドリング付きで実装
   - try-catch文による安全な処理

6. **JSX表示箇所の修正**:
   - 全ての商品名、価格、数量表示で`safeRender`系関数を使用
   - エラーメッセージ表示も`safeRender`で包む

7. **エラー境界でコンポーネント全体を包む**:
   ```typescript
   return (
     <ProductSelectionErrorBoundary>
       {/* 既存のJSX */}
     </ProductSelectionErrorBoundary>
   );
   ```

### Step 2: API ルートの修正

1. **ファイルを開く**: `src/app/api/admin/preset-products/[presetId]/route.ts`

2. **GET関数のシグネチャ修正**:
   ```typescript
   export async function GET(
     request: NextRequest,
     { params }: { params: Promise<{ presetId: string }> }
   ) {
   ```

3. **パラメータ取得の修正**:
   ```typescript
   const { presetId } = await params;
   const id = Number(presetId);
   ```

4. **PUT関数も同様に修正**

### Step 3: useFormConfig フックの修正

1. **ファイルを開く**: `src/hooks/useFormConfig.ts`

2. **不要なインポートを削除**:
   ```typescript
   // logger関連のインポートを削除
   ```

3. **詳細なログ出力を追加**:
   - API呼び出し前後のログ
   - レスポンス時間の測定
   - エラー詳細の出力

4. **リトライ機能の実装**:
   - 指数バックオフによるリトライ
   - デバッグ情報の蓄積

## 📋 検証手順

### 1. 本番環境での確認

1. **ブラウザコンソールを開く**
2. **商品選択ページにアクセス**
3. **以下を確認**:
   - React Error #418が出力されないこと
   - 商品が正常に表示されること
   - 数量変更が正常に動作すること

### 2. ネットワークタブでの確認

1. **ネットワークタブを開く**
2. **API呼び出しを確認**:
   - `/api/form/{presetId}` が200で成功すること
   - `/api/admin/preset-products/{presetId}` が404でないこと

### 3. エラーハンドリングの確認

1. **意図的にエラーを発生させる**:
   - 無効なpresetIdでアクセス
   - ネットワークを切断してアクセス
2. **適切なエラーメッセージが表示されること**
3. **再試行ボタンが動作すること**

## 🚨 注意事項

### 実装時の重要ポイント

1. **型安全性の確保**:
   - 全ての外部データに対して型チェックを実施
   - `unknown`型から安全にキャストする

2. **エラーハンドリングの徹底**:
   - try-catch文による例外処理
   - ユーザーフレンドリーなエラーメッセージ

3. **ログ出力の充実**:
   - 問題特定のための詳細なログ
   - 本番環境でも確認可能なコンソールログ

4. **フォールバック機能**:
   - データ取得失敗時の代替表示
   - 再試行機能の提供

### デプロイ後の確認項目

1. **React Error #418の解消**:
   - ブラウザコンソールでエラーが出力されないこと
   - 商品選択UIが正常に動作すること

2. **API 404エラーの解消**:
   - 全てのAPIエンドポイントが正常に応答すること
   - ネットワークタブで404エラーが発生しないこと

3. **ユーザー体験の改善**:
   - 商品選択が正常に動作すること
   - エラー時に適切なメッセージが表示されること

## 📞 トラブルシューティング

### まだエラーが発生する場合

1. **Vercelキャッシュのクリア**:
   - Vercelダッシュボードでキャッシュをクリア
   - 再デプロイを実行

2. **ブラウザキャッシュのクリア**:
   - ハードリロード（Ctrl+Shift+R）
   - ブラウザキャッシュの完全削除

3. **ログの確認**:
   - ブラウザコンソールでエラーログを確認
   - Vercelの関数ログを確認

### 追加対応が必要な場合

1. **DatabaseService.tsの修正**:
   - 商品データ取得ロジックの見直し
   - フォールバック処理の追加

2. **型定義の見直し**:
   - Product型の厳密化
   - FormConfigResponse型の修正

---

**作成日**: 2025年8月5日  
**対象バージョン**: Next.js 15.4.3, React 19.1.0  
**緊急度**: 最高  
**実装者**: Kiro AI Assistant