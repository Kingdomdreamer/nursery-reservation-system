# ğŸ”§ ä¿è‚²åœ’ãƒ»ç¨®è‹—åº—äºˆç´„ã‚·ã‚¹ãƒ†ãƒ  æŠ€è¡“ä»•æ§˜æ›¸ v2.0

## ğŸ“‹ æ¦‚è¦

æœ¬æ›¸ã¯ä¿è‚²åœ’ãƒ»ç¨®è‹—åº—äºˆç´„ã‚·ã‚¹ãƒ†ãƒ ã®æŠ€è¡“çš„å®Ÿè£…è©³ç´°ã«ã¤ã„ã¦è¨˜è¿°ã—ãŸã‚‚ã®ã§ã™ã€‚é–‹ç™ºè€…å‘ã‘ã®è©³ç´°ãªæŠ€è¡“æƒ…å ±ã‚’æä¾›ã—ã¾ã™ã€‚

## ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦

### ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆå›³
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Frontend      â”‚    â”‚   Backend       â”‚    â”‚   Database      â”‚
â”‚   (Next.js)     â”‚â—„â”€â”€â–ºâ”‚   (Supabase)    â”‚â—„â”€â”€â–ºâ”‚  (PostgreSQL)   â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ - React         â”‚    â”‚ - Auth          â”‚    â”‚ - 16 Tables     â”‚
â”‚ - TypeScript    â”‚    â”‚ - Edge Func     â”‚    â”‚ - RLS           â”‚
â”‚ - Tailwind      â”‚    â”‚ - Storage       â”‚    â”‚ - Indexes       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚
         â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LINE Platform  â”‚    â”‚   Vercel        â”‚
â”‚                 â”‚    â”‚                 â”‚
â”‚ - Messaging API â”‚    â”‚ - Hosting       â”‚
â”‚ - Login API     â”‚    â”‚ - CI/CD         â”‚
â”‚ - LIFF          â”‚    â”‚ - Edge Network  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ—„ï¸ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆè©³ç´°

### ERå›³
```mermaid
erDiagram
    customers {
        UUID id PK
        VARCHAR full_name
        VARCHAR phone
        VARCHAR email
        VARCHAR postal_code
        TEXT address
        VARCHAR line_user_id
        TIMESTAMPTZ created_at
        TIMESTAMPTZ updated_at
    }
    
    product_categories {
        UUID id PK
        VARCHAR name
        TEXT description
        UUID parent_id FK
        INTEGER sort_order
        BOOLEAN is_active
        TIMESTAMPTZ created_at
        TIMESTAMPTZ updated_at
    }
    
    products {
        UUID id PK
        VARCHAR name
        TEXT description
        DECIMAL price
        UUID category_id FK
        VARCHAR unit
        INTEGER min_order_quantity
        INTEGER max_order_quantity
        VARCHAR variation_name
        TEXT image_url
        VARCHAR barcode
        VARCHAR tax_type
        BOOLEAN is_available
        INTEGER display_order
        TIMESTAMPTZ created_at
        TIMESTAMPTZ updated_at
    }
    
    reservations {
        UUID id PK
        VARCHAR reservation_number
        UUID customer_id FK
        DATE reservation_date
        TIME pickup_time_start
        TIME pickup_time_end
        VARCHAR status
        VARCHAR payment_status
        DECIMAL total_amount
        DECIMAL discount_amount
        DECIMAL final_amount
        TEXT notes
        TEXT admin_notes
        TIMESTAMPTZ confirmation_sent_at
        TIMESTAMPTZ reminder_sent_at
        TIMESTAMPTZ created_at
        TIMESTAMPTZ updated_at
    }
    
    reservation_items {
        UUID id PK
        UUID reservation_id FK
        UUID product_id FK
        INTEGER quantity
        DECIMAL unit_price
        DECIMAL subtotal
        DATE pickup_date
        TIMESTAMPTZ created_at
        TIMESTAMPTZ updated_at
    }
    
    customers ||--o{ reservations : "has"
    reservations ||--o{ reservation_items : "contains"
    products ||--o{ reservation_items : "included_in"
    product_categories ||--o{ products : "categorizes"
    product_categories ||--o{ product_categories : "parent_of"
```

### ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æˆ¦ç•¥

#### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹é‡è¦–ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
```sql
-- é »ç¹ãªæ¤œç´¢ç”¨
CREATE INDEX idx_reservations_date             ON reservations(reservation_date);
CREATE INDEX idx_reservations_status           ON reservations(status);
CREATE INDEX idx_reservations_customer         ON reservations(customer_id);
CREATE INDEX idx_customers_phone               ON customers(phone);
CREATE INDEX idx_customers_line_user_id        ON customers(line_user_id);
CREATE INDEX idx_products_category             ON products(category_id);
CREATE INDEX idx_products_available            ON products(is_available);
CREATE INDEX idx_reservation_items_reservation ON reservation_items(reservation_id);
CREATE INDEX idx_reservation_items_product     ON reservation_items(product_id);

-- è¤‡åˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_reservations_date_status ON reservations(reservation_date, status);
CREATE INDEX idx_products_category_available ON products(category_id, is_available);

-- éƒ¨åˆ†ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_active_products ON products(name) WHERE is_available = true;
CREATE INDEX idx_pending_reservations ON reservations(created_at) WHERE status = 'pending';
```

### Row Level Security (RLS) è¨­å®š

#### customers ãƒ†ãƒ¼ãƒ–ãƒ«
```sql
-- é¡§å®¢ã¯è‡ªåˆ†ã®æƒ…å ±ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
CREATE POLICY "customers_own_data" ON customers
    FOR ALL USING (
        auth.uid()::text = line_user_id OR
        auth.role() = 'authenticated'
    );

-- ç®¡ç†è€…ã¯å…¨ã¦ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
CREATE POLICY "admin_full_access" ON customers
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE user_id = auth.uid() 
            AND role IN ('admin', 'manager')
        )
    );
```

#### products ãƒ†ãƒ¼ãƒ–ãƒ«
```sql
-- å•†å“ã¯å…¨å“¡é–²è¦§å¯èƒ½ï¼ˆåˆ©ç”¨å¯èƒ½å•†å“ã®ã¿ï¼‰
CREATE POLICY "products_read_all" ON products
    FOR SELECT USING (is_available = true);

-- ç®¡ç†è€…ã®ã¿ç·¨é›†å¯èƒ½
CREATE POLICY "products_admin_only" ON products
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE user_id = auth.uid() 
            AND role IN ('admin', 'manager')
        )
    );
```

## ğŸ”§ APIè¨­è¨ˆ

### RESTful API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ

#### èªè¨¼é–¢é€£
```typescript
// èªè¨¼çŠ¶æ…‹ç¢ºèª
GET /api/auth/me
Response: {
  user: User | null,
  profile: UserProfile | null
}

// ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ
POST /api/auth/logout
Response: { success: boolean }
```

#### é¡§å®¢ç®¡ç†
```typescript
// é¡§å®¢æƒ…å ±å–å¾—
GET /api/customers/:id
Response: {
  data: Customer,
  success: boolean
}

// é¡§å®¢æƒ…å ±æ›´æ–°
PUT /api/customers/:id
Body: Partial<Customer>
Response: {
  data: Customer,
  success: boolean
}
```

#### å•†å“ç®¡ç†
```typescript
// å•†å“ä¸€è¦§å–å¾—
GET /api/products?category=:categoryId&page=:page&limit=:limit
Response: {
  data: Product[],
  pagination: {
    total: number,
    page: number,
    limit: number,
    totalPages: number
  }
}

// å•†å“è©³ç´°å–å¾—
GET /api/products/:id
Response: {
  data: Product & { category: ProductCategory },
  success: boolean
}
```

#### äºˆç´„ç®¡ç†
```typescript
// äºˆç´„ä½œæˆ
POST /api/reservations
Body: {
  customer_id: string,
  reservation_date: string,
  pickup_time_start: string,
  pickup_time_end: string,
  items: ReservationItemInput[]
}
Response: {
  data: Reservation,
  success: boolean
}

// äºˆç´„ä¸€è¦§å–å¾—ï¼ˆç®¡ç†è€…ç”¨ï¼‰
GET /api/admin/reservations?status=:status&date=:date
Response: {
  data: (Reservation & { customer: Customer, items: ReservationItem[] })[],
  stats: ReservationStats
}
```

### Supabase Edge Functions

#### è‡ªå‹•é€šçŸ¥æ©Ÿèƒ½
```typescript
// functions/send-notification/index.ts
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

serve(async (req) => {
  const { type, reservation_id, customer_id } = await req.json()
  
  // é¡§å®¢æƒ…å ±å–å¾—
  const customer = await getCustomer(customer_id)
  
  // é€šçŸ¥é€ä¿¡
  switch (type) {
    case 'confirmation':
      await sendConfirmationMessage(customer, reservation_id)
      break
    case 'reminder':
      await sendReminderMessage(customer, reservation_id)
      break
    case 'ready':
      await sendReadyNotification(customer, reservation_id)
      break
  }
  
  return new Response(JSON.stringify({ success: true }))
})
```

#### ãƒ‡ãƒ¼ã‚¿åˆ†ææ©Ÿèƒ½
```typescript
// functions/analytics/index.ts
serve(async (req) => {
  const { type, period } = await req.json()
  
  const analytics = await generateAnalytics(type, period)
  
  return new Response(JSON.stringify({
    data: analytics,
    generated_at: new Date().toISOString()
  }))
})

interface AnalyticsData {
  reservations: {
    total: number
    by_status: Record<string, number>
    by_date: Array<{ date: string, count: number }>
  }
  revenue: {
    total: number
    by_period: Array<{ period: string, amount: number }>
  }
  customers: {
    total: number
    new_customers: number
    repeat_customers: number
  }
}
```

## ğŸ¨ ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰è¨­è¨ˆ

### ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆæ§‹æˆ

#### ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 
```
app/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ common/           # å…±é€šã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â”‚   â”œâ”€â”€ Header.tsx
â”‚   â”‚   â”œâ”€â”€ Footer.tsx
â”‚   â”‚   â”œâ”€â”€ LoadingSpinner.tsx
â”‚   â”‚   â””â”€â”€ ConfirmDialog.tsx
â”‚   â”œâ”€â”€ forms/            # ãƒ•ã‚©ãƒ¼ãƒ é–¢é€£
â”‚   â”‚   â”œâ”€â”€ CustomerInfoForm.tsx
â”‚   â”‚   â”œâ”€â”€ ProductSelectionForm.tsx
â”‚   â”‚   â””â”€â”€ ReservationFormTemplate.tsx
â”‚   â”œâ”€â”€ admin/            # ç®¡ç†ç”»é¢
â”‚   â”‚   â”œâ”€â”€ AdminLayout.tsx
â”‚   â”‚   â”œâ”€â”€ ProductManagement.tsx
â”‚   â”‚   â”œâ”€â”€ ReservationList.tsx
â”‚   â”‚   â””â”€â”€ CustomerManagement.tsx
â”‚   â””â”€â”€ ui/               # UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚       â”œâ”€â”€ Button.tsx
â”‚       â”œâ”€â”€ Input.tsx
â”‚       â”œâ”€â”€ Modal.tsx
â”‚       â””â”€â”€ Table.tsx
â”œâ”€â”€ lib/                  # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
â”‚   â”œâ”€â”€ supabase.ts
â”‚   â”œâ”€â”€ auth.ts
â”‚   â”œâ”€â”€ utils.ts
â”‚   â””â”€â”€ constants.ts
â”œâ”€â”€ services/             # ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯
â”‚   â”œâ”€â”€ ProductService.ts
â”‚   â”œâ”€â”€ ReservationService.ts
â”‚   â”œâ”€â”€ CustomerService.ts
â”‚   â””â”€â”€ NotificationService.ts
â””â”€â”€ types/                # å‹å®šç¾©
    â”œâ”€â”€ database.ts
    â”œâ”€â”€ forms.ts
    â””â”€â”€ api.ts
```

#### çŠ¶æ…‹ç®¡ç†
```typescript
// Zustandä½¿ç”¨ä¾‹
import { create } from 'zustand'

interface ReservationStore {
  currentReservation: Partial<Reservation> | null
  selectedProducts: Product[]
  customerInfo: Partial<Customer> | null
  
  // Actions
  setCurrentReservation: (reservation: Partial<Reservation>) => void
  addProduct: (product: Product, quantity: number) => void
  removeProduct: (productId: string) => void
  updateCustomerInfo: (info: Partial<Customer>) => void
  clearReservation: () => void
}

export const useReservationStore = create<ReservationStore>((set) => ({
  currentReservation: null,
  selectedProducts: [],
  customerInfo: null,
  
  setCurrentReservation: (reservation) => 
    set({ currentReservation: reservation }),
  
  addProduct: (product, quantity) => 
    set((state) => ({
      selectedProducts: [
        ...state.selectedProducts.filter(p => p.id !== product.id),
        { ...product, quantity }
      ]
    })),
  
  removeProduct: (productId) => 
    set((state) => ({
      selectedProducts: state.selectedProducts.filter(p => p.id !== productId)
    })),
  
  updateCustomerInfo: (info) => 
    set((state) => ({
      customerInfo: { ...state.customerInfo, ...info }
    })),
  
  clearReservation: () => 
    set({
      currentReservation: null,
      selectedProducts: [],
      customerInfo: null
    })
}))
```

### ãƒ•ã‚©ãƒ¼ãƒ ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³

#### React Hook Form + Zod
```typescript
import { z } from 'zod'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'

// ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¹ã‚­ãƒ¼ãƒ
const customerSchema = z.object({
  full_name: z.string()
    .min(1, 'æ°åã¯å¿…é ˆã§ã™')
    .max(100, 'æ°åã¯100æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„'),
  
  phone: z.string()
    .regex(/^0\d{9,10}$/, 'æ­£ã—ã„é›»è©±ç•ªå·ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'),
  
  email: z.string()
    .email('æ­£ã—ã„ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„')
    .optional()
    .or(z.literal('')),
  
  postal_code: z.string()
    .regex(/^\d{3}-?\d{4}$/, 'æ­£ã—ã„éƒµä¾¿ç•ªå·ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„')
    .optional()
    .or(z.literal('')),
  
  address: z.string()
    .max(500, 'ä½æ‰€ã¯500æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„')
    .optional()
    .or(z.literal(''))
})

type CustomerFormData = z.infer<typeof customerSchema>

// ãƒ•ã‚©ãƒ¼ãƒ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
export const CustomerInfoForm = ({ onSubmit }: { onSubmit: (data: CustomerFormData) => void }) => {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting }
  } = useForm<CustomerFormData>({
    resolver: zodResolver(customerSchema)
  })
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label>æ°å *</label>
        <input {...register('full_name')} />
        {errors.full_name && (
          <span className="error">{errors.full_name.message}</span>
        )}
      </div>
      
      <div>
        <label>é›»è©±ç•ªå· *</label>
        <input {...register('phone')} type="tel" />
        {errors.phone && (
          <span className="error">{errors.phone.message}</span>
        )}
      </div>
      
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'é€ä¿¡ä¸­...' : 'é€ä¿¡'}
      </button>
    </form>
  )
}
```

## ğŸ” ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å®Ÿè£…

### èªè¨¼ãƒ•ãƒ­ãƒ¼

#### LINE Loginå®Ÿè£…
```typescript
// lib/line-auth.ts
import { supabase } from './supabase'

export class LineAuthService {
  static async authenticateWithLIFF(): Promise<AuthResult> {
    try {
      // LIFFåˆæœŸåŒ–
      await liff.init({ liffId: process.env.NEXT_PUBLIC_LIFF_ID! })
      
      if (!liff.isLoggedIn()) {
        liff.login()
        return { success: false, error: 'Login required' }
      }
      
      // LINEãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«å–å¾—
      const profile = await liff.getProfile()
      const idToken = liff.getIDToken()
      
      // Supabaseã‚«ã‚¹ã‚¿ãƒ èªè¨¼
      const { data, error } = await supabase.auth.signInWithIdToken({
        provider: 'line',
        token: idToken
      })
      
      if (error) throw error
      
      // é¡§å®¢æƒ…å ±ã®ä½œæˆ/æ›´æ–°
      await this.upsertCustomer(profile, data.user)
      
      return { success: true, user: data.user, profile }
      
    } catch (error) {
      console.error('LINEèªè¨¼ã‚¨ãƒ©ãƒ¼:', error)
      return { success: false, error: error.message }
    }
  }
  
  private static async upsertCustomer(
    lineProfile: LineProfile,
    user: User
  ): Promise<Customer> {
    const { data, error } = await supabase
      .from('customers')
      .upsert({
        line_user_id: lineProfile.userId,
        full_name: lineProfile.displayName,
        email: user.email
      }, {
        onConflict: 'line_user_id',
        ignoreDuplicates: false
      })
      .select()
      .single()
    
    if (error) throw error
    return data
  }
}
```

#### JWTæ¤œè¨¼
```typescript
// middleware.ts
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export async function middleware(req: NextRequest) {
  const res = NextResponse.next()
  const supabase = createMiddlewareClient({ req, res })
  
  // ã‚»ãƒƒã‚·ãƒ§ãƒ³ç¢ºèª
  const {
    data: { session },
  } = await supabase.auth.getSession()
  
  // ç®¡ç†ç”»é¢ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡
  if (req.nextUrl.pathname.startsWith('/admin')) {
    if (!session) {
      return NextResponse.redirect(new URL('/login', req.url))
    }
    
    // ç®¡ç†è€…æ¨©é™ç¢ºèª
    const { data: profile } = await supabase
      .from('user_profiles')
      .select('role')
      .eq('user_id', session.user.id)
      .single()
    
    if (!profile || !['admin', 'manager'].includes(profile.role)) {
      return NextResponse.redirect(new URL('/unauthorized', req.url))
    }
  }
  
  return res
}

export const config = {
  matcher: ['/admin/:path*', '/api/admin/:path*']
}
```

### ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–

#### æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
```typescript
// lib/encryption.ts
import crypto from 'crypto'

const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY!
const ALGORITHM = 'aes-256-gcm'

export class EncryptionService {
  static encrypt(text: string): string {
    const iv = crypto.randomBytes(16)
    const cipher = crypto.createCipher(ALGORITHM, ENCRYPTION_KEY)
    cipher.setAAD(Buffer.from('additional-data'))
    
    let encrypted = cipher.update(text, 'utf8', 'hex')
    encrypted += cipher.final('hex')
    
    const authTag = cipher.getAuthTag()
    
    return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`
  }
  
  static decrypt(encryptedData: string): string {
    const [ivHex, authTagHex, encrypted] = encryptedData.split(':')
    
    const iv = Buffer.from(ivHex, 'hex')
    const authTag = Buffer.from(authTagHex, 'hex')
    
    const decipher = crypto.createDecipher(ALGORITHM, ENCRYPTION_KEY)
    decipher.setAAD(Buffer.from('additional-data'))
    decipher.setAuthTag(authTag)
    
    let decrypted = decipher.update(encrypted, 'hex', 'utf8')
    decrypted += decipher.final('utf8')
    
    return decrypted
  }
}

// ä½¿ç”¨ä¾‹ï¼šæ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ä¿å­˜æ™‚
const encryptedPhone = EncryptionService.encrypt(phoneNumber)
await supabase.from('customers').insert({
  ...customerData,
  phone: encryptedPhone
})
```

## ğŸ“± LINEé€£æºå®Ÿè£…

### LIFF ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š

#### LIFFåˆæœŸåŒ–
```typescript
// lib/liff.ts
declare global {
  interface Window {
    liff: any
  }
}

export class LIFFService {
  private static initialized = false
  
  static async initialize(): Promise<boolean> {
    if (this.initialized) return true
    
    try {
      await window.liff.init({
        liffId: process.env.NEXT_PUBLIC_LIFF_ID!
      })
      
      this.initialized = true
      return true
      
    } catch (error) {
      console.error('LIFFåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error)
      return false
    }
  }
  
  static isLoggedIn(): boolean {
    return this.initialized && window.liff.isLoggedIn()
  }
  
  static async getProfile(): Promise<LineProfile | null> {
    if (!this.isLoggedIn()) return null
    
    try {
      return await window.liff.getProfile()
    } catch (error) {
      console.error('ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«å–å¾—ã‚¨ãƒ©ãƒ¼:', error)
      return null
    }
  }
  
  static login(): void {
    if (this.initialized) {
      window.liff.login()
    }
  }
  
  static logout(): void {
    if (this.initialized) {
      window.liff.logout()
    }
  }
  
  static closeWindow(): void {
    if (this.initialized && window.liff.isInClient()) {
      window.liff.closeWindow()
    }
  }
  
  static async shareTargetPicker(message: any): Promise<void> {
    if (this.initialized && window.liff.isApiAvailable('shareTargetPicker')) {
      await window.liff.shareTargetPicker(message)
    }
  }
}
```

### Messaging APIå®Ÿè£…

#### è‡ªå‹•é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
```typescript
// services/LineMessagingService.ts
import { Client, FlexMessage, TextMessage } from '@line/bot-sdk'

export class LineMessagingService {
  private client: Client
  
  constructor() {
    this.client = new Client({
      channelAccessToken: process.env.LINE_CHANNEL_ACCESS_TOKEN!,
      channelSecret: process.env.LINE_CHANNEL_SECRET!
    })
  }
  
  // äºˆç´„ç¢ºèªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
  async sendReservationConfirmation(
    lineUserId: string,
    reservation: Reservation,
    items: ReservationItem[]
  ): Promise<boolean> {
    try {
      const message = this.createReservationConfirmationMessage(reservation, items)
      
      await this.client.pushMessage(lineUserId, message)
      
      // é€ä¿¡ãƒ­ã‚°è¨˜éŒ²
      await this.logMessage(lineUserId, 'confirmation', message)
      
      return true
      
    } catch (error) {
      console.error('LINEé€ä¿¡ã‚¨ãƒ©ãƒ¼:', error)
      return false
    }
  }
  
  // å—å–æº–å‚™å®Œäº†é€šçŸ¥
  async sendReadyNotification(
    lineUserId: string,
    reservation: Reservation
  ): Promise<boolean> {
    const message: FlexMessage = {
      type: 'flex',
      altText: 'ã”æ³¨æ–‡ã®å•†å“ã®æº–å‚™ãŒå®Œäº†ã—ã¾ã—ãŸ',
      contents: {
        type: 'bubble',
        header: {
          type: 'box',
          layout: 'vertical',
          contents: [
            {
              type: 'text',
              text: 'å•†å“æº–å‚™å®Œäº†ğŸŒ±',
              weight: 'bold',
              size: 'lg',
              color: '#2ecc71'
            }
          ]
        },
        body: {
          type: 'box',
          layout: 'vertical',
          contents: [
            {
              type: 'text',
              text: `äºˆç´„ç•ªå·: ${reservation.reservation_number}`,
              size: 'md',
              weight: 'bold'
            },
            {
              type: 'text',
              text: `å—å–äºˆå®š: ${reservation.reservation_date}`,
              size: 'sm',
              color: '#666666'
            },
            {
              type: 'text',
              text: 'ã”æ³¨æ–‡ã„ãŸã ã„ãŸå•†å“ã®æº–å‚™ãŒå®Œäº†ã„ãŸã—ã¾ã—ãŸã€‚æŒ‡å®šã®ãŠæ™‚é–“ã«ãŠè¶Šã—ãã ã•ã„ã€‚',
              wrap: true,
              margin: 'md'
            }
          ]
        },
        footer: {
          type: 'box',
          layout: 'vertical',
          contents: [
            {
              type: 'button',
              action: {
                type: 'uri',
                label: 'äºˆç´„è©³ç´°ã‚’ç¢ºèª',
                uri: `${process.env.NEXT_PUBLIC_BASE_URL}/reservations/${reservation.id}`
              },
              style: 'primary'
            }
          ]
        }
      }
    }
    
    return await this.sendMessage(lineUserId, message, 'ready')
  }
  
  private async sendMessage(
    lineUserId: string,
    message: any,
    type: string
  ): Promise<boolean> {
    try {
      await this.client.pushMessage(lineUserId, message)
      await this.logMessage(lineUserId, type, message)
      return true
    } catch (error) {
      console.error('LINEé€ä¿¡ã‚¨ãƒ©ãƒ¼:', error)
      return false
    }
  }
  
  private async logMessage(
    lineUserId: string,
    type: string,
    message: any
  ): Promise<void> {
    await supabase.from('line_message_logs').insert({
      line_user_id: lineUserId,
      message_type: type,
      message_content: message,
      sent_at: new Date().toISOString()
    })
  }
}
```

## ğŸš€ ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ

### Vercelè¨­å®š

#### vercel.json
```json
{
  "framework": "nextjs",
  "buildCommand": "npm run build",
  "devCommand": "npm run dev",
  "installCommand": "npm install",
  "functions": {
    "app/api/**/*.ts": {
      "maxDuration": 30
    }
  },
  "env": {
    "NEXT_PUBLIC_SUPABASE_URL": "@supabase-url",
    "NEXT_PUBLIC_SUPABASE_ANON_KEY": "@supabase-anon-key",
    "NEXT_PUBLIC_LIFF_ID": "@liff-id",
    "LINE_CHANNEL_ACCESS_TOKEN": "@line-access-token",
    "LINE_CHANNEL_SECRET": "@line-channel-secret"
  },
  "headers": [
    {
      "source": "/api/(.*)",
      "headers": [
        {
          "key": "Access-Control-Allow-Origin",
          "value": "*"
        },
        {
          "key": "Access-Control-Allow-Methods",
          "value": "GET, POST, PUT, DELETE, OPTIONS"
        },
        {
          "key": "Access-Control-Allow-Headers",
          "value": "X-Requested-With, Content-Type, Authorization"
        }
      ]
    }
  ]
}
```

### CI/CD ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³

#### GitHub Actions
```yaml
# .github/workflows/deploy.yml
name: Deploy to Vercel

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run tests
        run: npm run test
      
      - name: Run linting
        run: npm run lint
      
      - name: Type check
        run: npm run type-check
      
      - name: Build application
        run: npm run build

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v20
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.ORG_ID }}
          vercel-project-id: ${{ secrets.PROJECT_ID }}
          vercel-args: '--prod'
```

## ğŸ“Š ç›£è¦–ãƒ»ãƒ­ã‚°

### ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

#### åŒ…æ‹¬çš„ã‚¨ãƒ©ãƒ¼å‡¦ç†
```typescript
// lib/error-handler.ts
export class AppError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 500,
    public details?: any
  ) {
    super(message)
    this.name = 'AppError'
  }
}

export class ErrorHandler {
  static handle(error: unknown): { message: string; code: string; statusCode: number } {
    if (error instanceof AppError) {
      return {
        message: error.message,
        code: error.code,
        statusCode: error.statusCode
      }
    }
    
    if (error instanceof Error) {
      return {
        message: 'ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ',
        code: 'INTERNAL_ERROR',
        statusCode: 500
      }
    }
    
    return {
      message: 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ',
      code: 'UNKNOWN_ERROR',
      statusCode: 500
    }
  }
  
  static async log(error: unknown, context?: any): Promise<void> {
    const errorInfo = this.handle(error)
    
    // Supabaseãƒ­ã‚°ãƒ†ãƒ¼ãƒ–ãƒ«ã«è¨˜éŒ²
    await supabase.from('error_logs').insert({
      message: errorInfo.message,
      code: errorInfo.code,
      status_code: errorInfo.statusCode,
      context: context,
      stack: error instanceof Error ? error.stack : null,
      timestamp: new Date().toISOString()
    })
    
    // é‡è¦ãªã‚¨ãƒ©ãƒ¼ã¯Slacké€šçŸ¥
    if (errorInfo.statusCode >= 500) {
      await this.notifySlack(errorInfo, context)
    }
  }
  
  private static async notifySlack(
    error: { message: string; code: string },
    context?: any
  ): Promise<void> {
    // Slacké€šçŸ¥å®Ÿè£…
    console.error('Critical Error:', error, context)
  }
}
```

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–

#### ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†
```typescript
// lib/metrics.ts
export class MetricsCollector {
  static async trackPageView(page: string, userId?: string): Promise<void> {
    await supabase.from('page_views').insert({
      page,
      user_id: userId,
      timestamp: new Date().toISOString(),
      user_agent: navigator.userAgent
    })
  }
  
  static async trackApiCall(
    endpoint: string,
    method: string,
    responseTime: number,
    statusCode: number
  ): Promise<void> {
    await supabase.from('api_metrics').insert({
      endpoint,
      method,
      response_time: responseTime,
      status_code: statusCode,
      timestamp: new Date().toISOString()
    })
  }
  
  static async trackReservationFlow(
    step: string,
    sessionId: string,
    duration?: number
  ): Promise<void> {
    await supabase.from('reservation_flow_metrics').insert({
      step,
      session_id: sessionId,
      duration,
      timestamp: new Date().toISOString()
    })
  }
}

// APIå‘¼ã³å‡ºã—æ™‚ã®ä½¿ç”¨ä¾‹
const startTime = Date.now()
try {
  const result = await apiCall()
  MetricsCollector.trackApiCall('/api/reservations', 'POST', Date.now() - startTime, 200)
  return result
} catch (error) {
  MetricsCollector.trackApiCall('/api/reservations', 'POST', Date.now() - startTime, 500)
  throw error
}
```

---

**ä½œæˆæ—¥**: 2025å¹´7æœˆ19æ—¥  
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 2.0  
**æœ€çµ‚æ›´æ–°**: 2025å¹´7æœˆ19æ—¥  
**å¯¾è±¡ã‚·ã‚¹ãƒ†ãƒ **: ä¿è‚²åœ’ãƒ»ç¨®è‹—åº—äºˆç´„ã‚·ã‚¹ãƒ†ãƒ 