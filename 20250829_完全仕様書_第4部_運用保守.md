# å•†å“äºˆç´„ã‚·ã‚¹ãƒ†ãƒ å®Œå…¨ä»•æ§˜æ›¸ ç¬¬4éƒ¨ - é‹ç”¨ãƒ»ä¿å®ˆ

## ğŸš€ **ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆä»•æ§˜**

### **1. ç’°å¢ƒæ§‹æˆ**

#### **ç’°å¢ƒåˆ¥è¨­å®š**
```typescript
// é–‹ç™ºç’°å¢ƒ (development)
const developmentConfig = {
  database: {
    url: 'http://localhost:54321',
    poolSize: 5,
    ssl: false
  },
  line: {
    liffId: 'dev-liff-id',
    channelSecret: 'dev-channel-secret',
    accessToken: 'dev-access-token'
  },
  logging: {
    level: 'debug',
    console: true,
    file: false
  },
  rateLimit: {
    enabled: false
  }
};

// ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ç’°å¢ƒ (staging)
const stagingConfig = {
  database: {
    url: process.env.STAGING_SUPABASE_URL,
    poolSize: 10,
    ssl: true
  },
  line: {
    liffId: process.env.STAGING_LIFF_ID,
    channelSecret: process.env.STAGING_LINE_CHANNEL_SECRET,
    accessToken: process.env.STAGING_LINE_ACCESS_TOKEN
  },
  logging: {
    level: 'info',
    console: true,
    file: true,
    external: 'sentry'
  },
  rateLimit: {
    enabled: true,
    requests: 100,
    window: '15m'
  }
};

// æœ¬ç•ªç’°å¢ƒ (production)
const productionConfig = {
  database: {
    url: process.env.SUPABASE_URL,
    poolSize: 20,
    ssl: true,
    connectionTimeout: 30000
  },
  line: {
    liffId: process.env.LIFF_ID,
    channelSecret: process.env.LINE_CHANNEL_SECRET,
    accessToken: process.env.LINE_ACCESS_TOKEN
  },
  logging: {
    level: 'warn',
    console: false,
    file: true,
    external: 'sentry',
    structured: true
  },
  rateLimit: {
    enabled: true,
    requests: 60,
    window: '15m'
  },
  monitoring: {
    healthCheck: true,
    metrics: true,
    alerts: true
  }
};
```

#### **å¿…é ˆç’°å¢ƒå¤‰æ•°**
```bash
# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key

# LINEé€£æº
NEXT_PUBLIC_LIFF_ID=your-liff-id
LINE_MESSAGING_ACCESS_TOKEN=your-messaging-access-token
LINE_MESSAGING_CHANNEL_SECRET=your-channel-secret

# ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³
NEXT_PUBLIC_BASE_URL=https://your-domain.com
ADMIN_PASSWORD=your-secure-admin-password

# ç›£è¦–ãƒ»ãƒ­ã‚°ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
SENTRY_DSN=your-sentry-dsn
VERCEL_ANALYTICS_ID=your-analytics-id

# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
NEXTAUTH_SECRET=your-nextauth-secret
ENCRYPTION_KEY=your-encryption-key
```

### **2. Vercelãƒ‡ãƒ—ãƒ­ã‚¤è¨­å®š**

#### **vercel.json**
```json
{
  "version": 2,
  "builds": [
    {
      "src": "package.json",
      "use": "@vercel/next"
    }
  ],
  "routes": [
    {
      "src": "/api/health",
      "dest": "/api/health"
    },
    {
      "src": "/admin/(.*)",
      "dest": "/admin/$1"
    },
    {
      "src": "/(.*)",
      "dest": "/$1"
    }
  ],
  "env": {
    "NODE_ENV": "production"
  },
  "functions": {
    "src/app/api/**/*.ts": {
      "maxDuration": 30
    }
  },
  "headers": [
    {
      "source": "/api/(.*)",
      "headers": [
        {
          "key": "Access-Control-Allow-Origin",
          "value": "*"
        },
        {
          "key": "Access-Control-Allow-Methods",
          "value": "GET, POST, PUT, DELETE, OPTIONS"
        },
        {
          "key": "Access-Control-Allow-Headers",
          "value": "Content-Type, Authorization"
        }
      ]
    }
  ]
}
```

#### **next.config.js**
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    serverComponentsExternalPackages: ['@supabase/supabase-js']
  },
  images: {
    domains: ['line.me', 'profile.line-scdn.net'],
    formats: ['image/webp', 'image/avif']
  },
  async headers() {
    return [
      {
        source: '/api/:path*',
        headers: [
          { key: 'Access-Control-Allow-Credentials', value: 'true' },
          { key: 'Access-Control-Allow-Origin', value: '*' },
          { key: 'Access-Control-Allow-Methods', value: 'GET,OPTIONS,PATCH,DELETE,POST,PUT' },
          { key: 'Access-Control-Allow-Headers', value: 'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version' },
        ]
      }
    ];
  },
  async rewrites() {
    return [
      {
        source: '/admin',
        destination: '/admin/dashboard'
      }
    ];
  }
};

module.exports = nextConfig;
```

## ğŸ“Š **ç›£è¦–ãƒ»ãƒ­ã‚°ä»•æ§˜**

### **1. æ§‹é€ åŒ–ãƒ­ã‚°è¨­è¨ˆ**

#### **ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«å®šç¾©**
```typescript
enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
  FATAL = 4
}

interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  context?: string;
  userId?: string;
  sessionId?: string;
  requestId?: string;
  metadata?: Record<string, unknown>;
  error?: {
    name: string;
    message: string;
    stack?: string;
    cause?: unknown;
  };
}
```

#### **ãƒ­ã‚°å®Ÿè£…**
```typescript
class Logger {
  private static instance: Logger;
  private logLevel: LogLevel;
  
  constructor() {
    this.logLevel = this.getLogLevel();
  }
  
  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }
  
  private getLogLevel(): LogLevel {
    const level = process.env.LOG_LEVEL?.toUpperCase() || 'INFO';
    return LogLevel[level as keyof typeof LogLevel] || LogLevel.INFO;
  }
  
  private log(level: LogLevel, message: string, context?: string, metadata?: Record<string, unknown>, error?: Error): void {
    if (level < this.logLevel) return;
    
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      context,
      metadata,
      error: error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : undefined
    };
    
    // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›
    if (process.env.NODE_ENV === 'development') {
      console.log(JSON.stringify(entry, null, 2));
    } else {
      console.log(JSON.stringify(entry));
    }
    
    // å¤–éƒ¨ãƒ­ã‚°ã‚µãƒ¼ãƒ“ã‚¹é€ä¿¡
    if (process.env.NODE_ENV === 'production') {
      this.sendToExternalService(entry);
    }
  }
  
  debug(message: string, context?: string, metadata?: Record<string, unknown>): void {
    this.log(LogLevel.DEBUG, message, context, metadata);
  }
  
  info(message: string, context?: string, metadata?: Record<string, unknown>): void {
    this.log(LogLevel.INFO, message, context, metadata);
  }
  
  warn(message: string, context?: string, metadata?: Record<string, unknown>): void {
    this.log(LogLevel.WARN, message, context, metadata);
  }
  
  error(message: string, error?: Error, context?: string, metadata?: Record<string, unknown>): void {
    this.log(LogLevel.ERROR, message, context, metadata, error);
  }
  
  fatal(message: string, error?: Error, context?: string, metadata?: Record<string, unknown>): void {
    this.log(LogLevel.FATAL, message, context, metadata, error);
  }
  
  private async sendToExternalService(entry: LogEntry): Promise<void> {
    // Sentryã€DataDogã€CloudWatchç­‰ã¸ã®é€ä¿¡
    try {
      if (process.env.SENTRY_DSN && entry.level >= LogLevel.ERROR) {
        // Sentryã«ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã‚’é€ä¿¡
        // await Sentry.captureException(entry);
      }
    } catch (err) {
      console.error('Failed to send log to external service:', err);
    }
  }
}

export const logger = Logger.getInstance();
```

### **2. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–**

#### **ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†**
```typescript
interface PerformanceMetrics {
  // API ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“
  apiResponseTime: {
    endpoint: string;
    method: string;
    duration: number;
    status: number;
    timestamp: string;
  };
  
  // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¯ã‚¨ãƒªæ™‚é–“
  databaseQueryTime: {
    query: string;
    duration: number;
    rowCount?: number;
    timestamp: string;
  };
  
  // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡
  memoryUsage: {
    heapUsed: number;
    heapTotal: number;
    external: number;
    timestamp: string;
  };
  
  // ã‚¨ãƒ©ãƒ¼ç‡
  errorRate: {
    endpoint: string;
    errorCount: number;
    totalRequests: number;
    rate: number;
    timeWindow: string;
  };
}

class PerformanceMonitor {
  private metrics: PerformanceMetrics[] = [];
  
  recordApiResponse(endpoint: string, method: string, duration: number, status: number): void {
    this.metrics.push({
      apiResponseTime: {
        endpoint,
        method,
        duration,
        status,
        timestamp: new Date().toISOString()
      }
    } as PerformanceMetrics);
    
    // è­¦å‘Šã—ãã„å€¤ãƒã‚§ãƒƒã‚¯
    if (duration > 5000) { // 5ç§’ä»¥ä¸Š
      logger.warn(`Slow API response detected`, 'performance', {
        endpoint,
        method,
        duration,
        status
      });
    }
  }
  
  recordDatabaseQuery(query: string, duration: number, rowCount?: number): void {
    this.metrics.push({
      databaseQueryTime: {
        query: query.substring(0, 100), // ã‚¯ã‚¨ãƒªã‚’100æ–‡å­—ã«åˆ¶é™
        duration,
        rowCount,
        timestamp: new Date().toISOString()
      }
    } as PerformanceMetrics);
    
    // é…ã„ã‚¯ã‚¨ãƒªã®è­¦å‘Š
    if (duration > 1000) { // 1ç§’ä»¥ä¸Š
      logger.warn(`Slow database query detected`, 'database', {
        query: query.substring(0, 100),
        duration,
        rowCount
      });
    }
  }
  
  getMetrics(): PerformanceMetrics[] {
    return this.metrics;
  }
  
  clearMetrics(): void {
    this.metrics = [];
  }
}

export const performanceMonitor = new PerformanceMonitor();
```

### **3. ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯**

#### **ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ**
```typescript
// /api/health
export async function GET(): Promise<NextResponse> {
  const healthCheck = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    version: process.env.npm_package_version || '1.0.0',
    environment: process.env.NODE_ENV,
    services: {} as Record<string, ServiceHealth>
  };
  
  try {
    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šç¢ºèª
    const dbHealth = await checkDatabaseHealth();
    healthCheck.services.database = dbHealth;
    
    // LINE APIæ¥ç¶šç¢ºèª
    const lineHealth = await checkLineApiHealth();
    healthCheck.services.lineApi = lineHealth;
    
    // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ç¢ºèª
    const memoryHealth = checkMemoryHealth();
    healthCheck.services.memory = memoryHealth;
    
    // å…¨ä½“ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ¤å®š
    const allHealthy = Object.values(healthCheck.services).every(
      service => service.status === 'healthy'
    );
    
    healthCheck.status = allHealthy ? 'healthy' : 'degraded';
    
    const statusCode = allHealthy ? 200 : 503;
    return NextResponse.json(healthCheck, { status: statusCode });
    
  } catch (error) {
    logger.error('Health check failed', error as Error, 'health-check');
    
    return NextResponse.json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 503 });
  }
}

interface ServiceHealth {
  status: 'healthy' | 'degraded' | 'unhealthy';
  responseTime?: number;
  details?: Record<string, unknown>;
}

async function checkDatabaseHealth(): Promise<ServiceHealth> {
  const startTime = Date.now();
  
  try {
    const { data, error } = await supabaseAdmin
      .from('products')
      .select('count')
      .limit(1);
    
    const responseTime = Date.now() - startTime;
    
    if (error) {
      return {
        status: 'unhealthy',
        responseTime,
        details: { error: error.message }
      };
    }
    
    return {
      status: responseTime < 1000 ? 'healthy' : 'degraded',
      responseTime,
      details: { connectionPool: 'active' }
    };
    
  } catch (error) {
    return {
      status: 'unhealthy',
      responseTime: Date.now() - startTime,
      details: { error: error instanceof Error ? error.message : 'Unknown error' }
    };
  }
}

async function checkLineApiHealth(): Promise<ServiceHealth> {
  const startTime = Date.now();
  
  try {
    // LINE APIã®ç°¡å˜ãªæ¥ç¶šç¢ºèª
    const response = await fetch('https://api.line.me/v2/bot/info', {
      headers: {
        'Authorization': `Bearer ${process.env.LINE_MESSAGING_ACCESS_TOKEN}`
      }
    });
    
    const responseTime = Date.now() - startTime;
    
    return {
      status: response.ok ? 'healthy' : 'degraded',
      responseTime,
      details: { 
        httpStatus: response.status,
        rateLimitRemaining: response.headers.get('X-Line-Request-Id')
      }
    };
    
  } catch (error) {
    return {
      status: 'unhealthy',
      responseTime: Date.now() - startTime,
      details: { error: error instanceof Error ? error.message : 'Unknown error' }
    };
  }
}

function checkMemoryHealth(): ServiceHealth {
  const memoryUsage = process.memoryUsage();
  const heapUsedMB = Math.round(memoryUsage.heapUsed / 1024 / 1024);
  const heapTotalMB = Math.round(memoryUsage.heapTotal / 1024 / 1024);
  
  // ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡ãŒ80%ã‚’è¶…ãˆãŸã‚‰è­¦å‘Š
  const usageRatio = memoryUsage.heapUsed / memoryUsage.heapTotal;
  
  return {
    status: usageRatio < 0.8 ? 'healthy' : usageRatio < 0.9 ? 'degraded' : 'unhealthy',
    details: {
      heapUsedMB,
      heapTotalMB,
      usageRatio: Math.round(usageRatio * 100)
    }
  };
}
```

## ğŸ”’ **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä»•æ§˜**

### **1. èªè¨¼ãƒ»èªå¯**

#### **ç®¡ç†è€…èªè¨¼**
```typescript
// ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–
import bcrypt from 'bcrypt';

const SALT_ROUNDS = 12;
const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || 'admin123';

export async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, SALT_ROUNDS);
}

export async function verifyPassword(password: string, hash: string): Promise<boolean> {
  return bcrypt.compare(password, hash);
}

// ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†
interface AdminSession {
  id: string;
  userId: string;
  createdAt: Date;
  expiresAt: Date;
  ipAddress: string;
  userAgent: string;
}

class SessionManager {
  private sessions = new Map<string, AdminSession>();
  private readonly SESSION_DURATION = 24 * 60 * 60 * 1000; // 24æ™‚é–“
  
  createSession(userId: string, ipAddress: string, userAgent: string): string {
    const sessionId = crypto.randomUUID();
    const now = new Date();
    
    const session: AdminSession = {
      id: sessionId,
      userId,
      createdAt: now,
      expiresAt: new Date(now.getTime() + this.SESSION_DURATION),
      ipAddress,
      userAgent
    };
    
    this.sessions.set(sessionId, session);
    
    // æœŸé™åˆ‡ã‚Œã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    this.cleanupExpiredSessions();
    
    return sessionId;
  }
  
  validateSession(sessionId: string): AdminSession | null {
    const session = this.sessions.get(sessionId);
    
    if (!session || session.expiresAt < new Date()) {
      if (session) {
        this.sessions.delete(sessionId);
      }
      return null;
    }
    
    return session;
  }
  
  revokeSession(sessionId: string): void {
    this.sessions.delete(sessionId);
  }
  
  private cleanupExpiredSessions(): void {
    const now = new Date();
    for (const [id, session] of this.sessions.entries()) {
      if (session.expiresAt < now) {
        this.sessions.delete(id);
      }
    }
  }
}

export const sessionManager = new SessionManager();
```

#### **ãƒ¬ãƒ¼ãƒˆåˆ¶é™**
```typescript
interface RateLimitConfig {
  windowMs: number;
  maxRequests: number;
  skipSuccessfulRequests?: boolean;
  skipFailedRequests?: boolean;
}

class RateLimiter {
  private requests = new Map<string, number[]>();
  
  constructor(private config: RateLimitConfig) {}
  
  isAllowed(identifier: string): boolean {
    const now = Date.now();
    const windowStart = now - this.config.windowMs;
    
    // æ—¢å­˜ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆå±¥æ­´ã‚’å–å¾—
    const requestTimes = this.requests.get(identifier) || [];
    
    // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å¤–ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‰Šé™¤
    const validRequests = requestTimes.filter(time => time > windowStart);
    
    // åˆ¶é™ãƒã‚§ãƒƒã‚¯
    if (validRequests.length >= this.config.maxRequests) {
      return false;
    }
    
    // æ–°ã—ã„ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’è¨˜éŒ²
    validRequests.push(now);
    this.requests.set(identifier, validRequests);
    
    return true;
  }
  
  getRemainingRequests(identifier: string): number {
    const now = Date.now();
    const windowStart = now - this.config.windowMs;
    const requestTimes = this.requests.get(identifier) || [];
    const validRequests = requestTimes.filter(time => time > windowStart);
    
    return Math.max(0, this.config.maxRequests - validRequests.length);
  }
  
  getResetTime(identifier: string): number {
    const requestTimes = this.requests.get(identifier) || [];
    if (requestTimes.length === 0) return 0;
    
    const oldestRequest = Math.min(...requestTimes);
    return oldestRequest + this.config.windowMs;
  }
}

// APIåˆ¥ãƒ¬ãƒ¼ãƒˆåˆ¶é™è¨­å®š
export const rateLimiters = {
  general: new RateLimiter({ windowMs: 15 * 60 * 1000, maxRequests: 100 }), // 15åˆ†ã§100ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
  reservation: new RateLimiter({ windowMs: 60 * 1000, maxRequests: 5 }),     // 1åˆ†ã§5ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
  admin: new RateLimiter({ windowMs: 60 * 1000, maxRequests: 30 }),          // 1åˆ†ã§30ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
  import: new RateLimiter({ windowMs: 60 * 1000, maxRequests: 2 })           // 1åˆ†ã§2ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
};
```

### **2. ãƒ‡ãƒ¼ã‚¿ä¿è­·**

#### **å…¥åŠ›å€¤ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³**
```typescript
import DOMPurify from 'isomorphic-dompurify';

export function sanitizeInput(input: string): string {
  // HTMLã‚¿ã‚°ã®é™¤å»
  const cleaned = DOMPurify.sanitize(input, { ALLOWED_TAGS: [] });
  
  // åˆ¶å¾¡æ–‡å­—ã®é™¤å»
  return cleaned.replace(/[\x00-\x1F\x7F]/g, '');
}

export function sanitizePhoneNumber(phone: string): string {
  // é›»è©±ç•ªå·ã®æ­£è¦åŒ–ï¼ˆæ•°å­—ã€ãƒã‚¤ãƒ•ãƒ³ã€æ‹¬å¼§ã®ã¿è¨±å¯ï¼‰
  return phone.replace(/[^0-9\-()]/g, '');
}

export function sanitizeEmail(email: string): string {
  // ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®åŸºæœ¬çš„ãªã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
  return email.toLowerCase().trim();
}
```

#### **ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–**
```typescript
import crypto from 'crypto';

const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || crypto.randomBytes(32);
const ALGORITHM = 'aes-256-gcm';

export function encrypt(text: string): string {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipher(ALGORITHM, ENCRYPTION_KEY);
  
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  const authTag = cipher.getAuthTag();
  
  return iv.toString('hex') + ':' + authTag.toString('hex') + ':' + encrypted;
}

export function decrypt(encryptedData: string): string {
  const parts = encryptedData.split(':');
  const iv = Buffer.from(parts[0], 'hex');
  const authTag = Buffer.from(parts[1], 'hex');
  const encrypted = parts[2];
  
  const decipher = crypto.createDecipher(ALGORITHM, ENCRYPTION_KEY);
  decipher.setAuthTag(authTag);
  
  let decrypted = decipher.update(encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
}
```

## ğŸ”„ **ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ»å¾©æ—§**

### **1. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—**

#### **è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨­å®š**
```sql
-- Supabaseã®è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨­å®š
-- æ—¥æ¬¡ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼ˆ7æ—¥é–“ä¿æŒï¼‰
-- é€±æ¬¡ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼ˆ4é€±é–“ä¿æŒï¼‰
-- æœˆæ¬¡ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼ˆ12ãƒ¶æœˆä¿æŒï¼‰

-- æ‰‹å‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
-- pg_dump ã‚’ä½¿ç”¨ã—ãŸãƒ•ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
pg_dump -h your-host -U postgres -d your-database > backup_$(date +%Y%m%d_%H%M%S).sql

-- ãƒ†ãƒ¼ãƒ–ãƒ«åˆ¥ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
pg_dump -h your-host -U postgres -d your-database -t products > products_backup.sql
pg_dump -h your-host -U postgres -d your-database -t reservations > reservations_backup.sql
```

#### **å¾©æ—§æ‰‹é †**
```bash
# 1. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å¾©æ—§
psql -h your-host -U postgres -d your-database < backup_file.sql

# 2. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å†èµ·å‹•
vercel --prod

# 3. ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ç¢ºèª
curl https://your-domain.com/api/health

# 4. æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm run test:e2e
```

### **2. ç½å®³å¾©æ—§è¨ˆç”»**

#### **RTO/RPOç›®æ¨™**
- **RTO (Recovery Time Objective)**: 4æ™‚é–“ä»¥å†…
- **RPO (Recovery Point Objective)**: 1æ™‚é–“ä»¥å†…

#### **å¾©æ—§æ‰‹é †æ›¸**
```markdown
## ç½å®³å¾©æ—§æ‰‹é †

### Phase 1: çŠ¶æ³ç¢ºèªï¼ˆ15åˆ†ä»¥å†…ï¼‰
1. ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ã®ç¢ºèª
2. å½±éŸ¿ç¯„å›²ã®ç‰¹å®š
3. é–¢ä¿‚è€…ã¸ã®é€£çµ¡

### Phase 2: ç·Šæ€¥å¯¾å¿œï¼ˆ1æ™‚é–“ä»¥å†…ï¼‰
1. ã‚µãƒ¼ãƒ“ã‚¹åœæ­¢ã®å‘ŠçŸ¥
2. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®çŠ¶æ…‹ç¢ºèª
3. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ç¢ºèª

### Phase 3: å¾©æ—§ä½œæ¥­ï¼ˆ3æ™‚é–“ä»¥å†…ï¼‰
1. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å¾©æ—§
2. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å¾©æ—§
3. æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

### Phase 4: ã‚µãƒ¼ãƒ“ã‚¹å†é–‹ï¼ˆ4æ™‚é–“ä»¥å†…ï¼‰
1. å…¨æ©Ÿèƒ½ã®å‹•ä½œç¢ºèª
2. ã‚µãƒ¼ãƒ“ã‚¹å†é–‹ã®å‘ŠçŸ¥
3. ç›£è¦–ä½“åˆ¶ã®å¼·åŒ–
```