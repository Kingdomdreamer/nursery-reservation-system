# ÂïÜÂìÅ‰∫àÁ¥Ñ„Ç∑„Çπ„ÉÜ„É†ÂÆåÂÖ®‰ªïÊßòÊõ∏ Á¨¨4ÈÉ® - ÈÅãÁî®„Éª‰øùÂÆà

## üöÄ **„Éá„Éó„É≠„Ç§„É°„É≥„Éà‰ªïÊßò**

### **1. Áí∞Â¢ÉÊßãÊàê**

#### **Áí∞Â¢ÉÂà•Ë®≠ÂÆö**
```typescript
// ÈñãÁô∫Áí∞Â¢É (development)
const developmentConfig = {
  database: {
    url: 'http://localhost:54321',
    poolSize: 5,
    ssl: false
  },
  line: {
    liffId: 'dev-liff-id',
    channelSecret: 'dev-channel-secret',
    accessToken: 'dev-access-token'
  },
  logging: {
    level: 'debug',
    console: true,
    file: false
  },
  rateLimit: {
    enabled: false
  }
};

// „Çπ„ÉÜ„Éº„Ç∏„É≥„Ç∞Áí∞Â¢É (staging)
const stagingConfig = {
  database: {
    url: process.env.STAGING_SUPABASE_URL,
    poolSize: 10,
    ssl: true
  },
  line: {
    liffId: process.env.STAGING_LIFF_ID,
    channelSecret: process.env.STAGING_LINE_CHANNEL_SECRET,
    accessToken: process.env.STAGING_LINE_ACCESS_TOKEN
  },
  logging: {
    level: 'info',
    console: true,
    file: true,
    external: 'sentry'
  },
  rateLimit: {
    enabled: true,
    requests: 100,
    window: '15m'
  }
};

// Êú¨Áï™Áí∞Â¢É (production)
const productionConfig = {
  database: {
    url: process.env.SUPABASE_URL,
    poolSize: 20,
    ssl: true,
    connectionTimeout: 30000
  },
  line: {
    liffId: process.env.LIFF_ID,
    channelSecret: process.env.LINE_CHANNEL_SECRET,
    accessToken: process.env.LINE_ACCESS_TOKEN
  },
  logging: {
    level: 'warn',
    console: false,
    file: true,
    external: 'sentry',
    structured: true
  },
  rateLimit: {
    enabled: true,
    requests: 60,
    window: '15m'
  },
  monitoring: {
    healthCheck: true,
    metrics: true,
    alerts: true
  }
};
```

#### **ÂøÖÈ†àÁí∞Â¢ÉÂ§âÊï∞**
```bash
# „Éá„Éº„Çø„Éô„Éº„Çπ
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key

# LINEÈÄ£Êê∫
NEXT_PUBLIC_LIFF_ID=your-liff-id
LINE_MESSAGING_ACCESS_TOKEN=your-messaging-access-token
LINE_MESSAGING_CHANNEL_SECRET=your-channel-secret

# „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥
NEXT_PUBLIC_BASE_URL=https://your-domain.com
ADMIN_PASSWORD=your-secure-admin-password

# Áõ£Ë¶ñ„Éª„É≠„Ç∞Ôºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ
SENTRY_DSN=your-sentry-dsn
VERCEL_ANALYTICS_ID=your-analytics-id

# „Çª„Ç≠„É•„É™„ÉÜ„Ç£
NEXTAUTH_SECRET=your-nextauth-secret
ENCRYPTION_KEY=your-encryption-key
```

### **2. Vercel„Éá„Éó„É≠„Ç§Ë®≠ÂÆö**

#### **vercel.json**
```json
{
  "version": 2,
  "builds": [
    {
      "src": "package.json",
      "use": "@vercel/next"
    }
  ],
  "routes": [
    {
      "src": "/api/health",
      "dest": "/api/health"
    },
    {
      "src": "/admin/(.*)",
      "dest": "/admin/$1"
    },
    {
      "src": "/(.*)",
      "dest": "/$1"
    }
  ],
  "env": {
    "NODE_ENV": "production"
  },
  "functions": {
    "src/app/api/**/*.ts": {
      "maxDuration": 30
    }
  },
  "headers": [
    {
      "source": "/api/(.*)",
      "headers": [
        {
          "key": "Access-Control-Allow-Origin",
          "value": "*"
        },
        {
          "key": "Access-Control-Allow-Methods",
          "value": "GET, POST, PUT, DELETE, OPTIONS"
        },
        {
          "key": "Access-Control-Allow-Headers",
          "value": "Content-Type, Authorization"
        }
      ]
    }
  ]
}
```

#### **next.config.js**
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    serverComponentsExternalPackages: ['@supabase/supabase-js']
  },
  images: {
    domains: ['line.me', 'profile.line-scdn.net'],
    formats: ['image/webp', 'image/avif']
  },
  async headers() {
    return [
      {
        source: '/api/:path*',
        headers: [
          { key: 'Access-Control-Allow-Credentials', value: 'true' },
          { key: 'Access-Control-Allow-Origin', value: '*' },
          { key: 'Access-Control-Allow-Methods', value: 'GET,OPTIONS,PATCH,DELETE,POST,PUT' },
          { key: 'Access-Control-Allow-Headers', value: 'X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version' },
        ]
      }
    ];
  },
  async rewrites() {
    return [
      {
        source: '/admin',
        destination: '/admin/dashboard'
      }
    ];
  }
};

module.exports = nextConfig;
```

## üìä **Áõ£Ë¶ñ„Éª„É≠„Ç∞‰ªïÊßò**

### **1. ÊßãÈÄ†Âåñ„É≠„Ç∞Ë®≠Ë®à**

#### **„É≠„Ç∞„É¨„Éô„É´ÂÆöÁæ©**
```typescript
enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
  FATAL = 4
}

interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  context?: string;
  userId?: string;
  sessionId?: string;
  requestId?: string;
  metadata?: Record<string, unknown>;
  error?: {
    name: string;
    message: string;
    stack?: string;
    cause?: unknown;
  };
}
```

#### **„É≠„Ç∞ÂÆüË£Ö**
```typescript
class Logger {
  private static instance: Logger;
  private logLevel: LogLevel;
  
  constructor() {
    this.logLevel = this.getLogLevel();
  }
  
  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }
  
  private getLogLevel(): LogLevel {
    const level = process.env.LOG_LEVEL?.toUpperCase() || 'INFO';
    return LogLevel[level as keyof typeof LogLevel] || LogLevel.INFO;
  }
  
  private log(level: LogLevel, message: string, context?: string, metadata?: Record<string, unknown>, error?: Error): void {
    if (level < this.logLevel) return;
    
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      context,
      metadata,
      error: error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : undefined
    };
    
    // „Ç≥„É≥„ÇΩ„Éº„É´Âá∫Âäõ
    if (process.env.NODE_ENV === 'development') {
      console.log(JSON.stringify(entry, null, 2));
    } else {
      console.log(JSON.stringify(entry));
    }
    
    // Â§ñÈÉ®„É≠„Ç∞„Çµ„Éº„Éì„ÇπÈÄÅ‰ø°
    if (process.env.NODE_ENV === 'production') {
      this.sendToExternalService(entry);
    }
  }
  
  debug(message: string, context?: string, metadata?: Record<string, unknown>): void {
    this.log(LogLevel.DEBUG, message, context, metadata);
  }
  
  info(message: string, context?: string, metadata?: Record<string, unknown>): void {
    this.log(LogLevel.INFO, message, context, metadata);
  }
  
  warn(message: string, context?: string, metadata?: Record<string, unknown>): void {
    this.log(LogLevel.WARN, message, context, metadata);
  }
  
  error(message: string, error?: Error, context?: string, metadata?: Record<string, unknown>): void {
    this.log(LogLevel.ERROR, message, context, metadata, error);
  }
  
  fatal(message: string, error?: Error, context?: string, metadata?: Record<string, unknown>): void {
    this.log(LogLevel.FATAL, message, context, metadata, error);
  }
  
  private async sendToExternalService(entry: LogEntry): Promise<void> {
    // Sentry„ÄÅDataDog„ÄÅCloudWatchÁ≠â„Å∏„ÅÆÈÄÅ‰ø°
    try {
      if (process.env.SENTRY_DSN && entry.level >= LogLevel.ERROR) {
        // Sentry„Å´„Ç®„É©„Éº„É≠„Ç∞„ÇíÈÄÅ‰ø°
        // await Sentry.captureException(entry);
      }
    } catch (err) {
      console.error('Failed to send log to external service:', err);
    }
  }
}

export const logger = Logger.getInstance();
```

### **2. „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁõ£Ë¶ñ**

#### **„É°„Éà„É™„ÇØ„ÇπÂèéÈõÜ**
```typescript
interface PerformanceMetrics {
  // API „É¨„Çπ„Éù„É≥„ÇπÊôÇÈñì
  apiResponseTime: {
    endpoint: string;
    method: string;
    duration: number;
    status: number;
    timestamp: string;
  };
  
  // „Éá„Éº„Çø„Éô„Éº„Çπ„ÇØ„Ç®„É™ÊôÇÈñì
  databaseQueryTime: {
    query: string;
    duration: number;
    rowCount?: number;
    timestamp: string;
  };
  
  // „É°„É¢„É™‰ΩøÁî®Èáè
  memoryUsage: {
    heapUsed: number;
    heapTotal: number;
    external: number;
    timestamp: string;
  };
  
  // „Ç®„É©„ÉºÁéá
  errorRate: {
    endpoint: string;
    errorCount: number;
    totalRequests: number;
    rate: number;
    timeWindow: string;
  };
}

class PerformanceMonitor {
  private metrics: PerformanceMetrics[] = [];
  
  recordApiResponse(endpoint: string, method: string, duration: number, status: number): void {
    this.metrics.push({
      apiResponseTime: {
        endpoint,
        method,
        duration,
        status,
        timestamp: new Date().toISOString()
      }
    } as PerformanceMetrics);
    
    // Ë≠¶Âëä„Åó„Åç„ÅÑÂÄ§„ÉÅ„Çß„ÉÉ„ÇØ
    if (duration > 5000) { // 5Áßí‰ª•‰∏ä
      logger.warn(`Slow API response detected`, 'performance', {
        endpoint,
        method,
        duration,
        status
      });
    }
  }
  
  recordDatabaseQuery(query: string, duration: number, rowCount?: number): void {
    this.metrics.push({
      databaseQueryTime: {
        query: query.substring(0, 100), // „ÇØ„Ç®„É™„Çí100ÊñáÂ≠ó„Å´Âà∂Èôê
        duration,
        rowCount,
        timestamp: new Date().toISOString()
      }
    } as PerformanceMetrics);
    
    // ÈÅÖ„ÅÑ„ÇØ„Ç®„É™„ÅÆË≠¶Âëä
    if (duration > 1000) { // 1Áßí‰ª•‰∏ä
      logger.warn(`Slow database query detected`, 'database', {
        query: query.substring(0, 100),
        duration,
        rowCount
      });
    }
  }
  
  getMetrics(): PerformanceMetrics[] {
    return this.metrics;
  }
  
  clearMetrics(): void {
    this.metrics = [];
  }
}

export const performanceMonitor = new PerformanceMonitor();
```

### **3. „Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØ**

#### **„Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØ„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà**
```typescript
// /api/health
export async function GET(): Promise<NextResponse> {
  const healthCheck = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    version: process.env.npm_package_version || '1.0.0',
    environment: process.env.NODE_ENV,
    services: {} as Record<string, ServiceHealth>
  };
  
  try {
    // „Éá„Éº„Çø„Éô„Éº„ÇπÊé•Á∂öÁ¢∫Ë™ç
    const dbHealth = await checkDatabaseHealth();
    healthCheck.services.database = dbHealth;
    
    // LINE APIÊé•Á∂öÁ¢∫Ë™ç
    const lineHealth = await checkLineApiHealth();
    healthCheck.services.lineApi = lineHealth;
    
    // „É°„É¢„É™‰ΩøÁî®ÈáèÁ¢∫Ë™ç
    const memoryHealth = checkMemoryHealth();
    healthCheck.services.memory = memoryHealth;
    
    // ÂÖ®‰Ωì„Çπ„ÉÜ„Éº„Çø„ÇπÂà§ÂÆö
    const allHealthy = Object.values(healthCheck.services).every(
      service => service.status === 'healthy'
    );
    
    healthCheck.status = allHealthy ? 'healthy' : 'degraded';
    
    const statusCode = allHealthy ? 200 : 503;
    return NextResponse.json(healthCheck, { status: statusCode });
    
  } catch (error) {
    logger.error('Health check failed', error as Error, 'health-check');
    
    return NextResponse.json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 503 });
  }
}

interface ServiceHealth {
  status: 'healthy' | 'degraded' | 'unhealthy';
  responseTime?: number;
  details?: Record<string, unknown>;
}

async function checkDatabaseHealth(): Promise<ServiceHealth> {
  const startTime = Date.now();
  
  try {
    const { data, error } = await supabaseAdmin
      .from('products')
      .select('count')
      .limit(1);
    
    const responseTime = Date.now() - startTime;
    
    if (error) {
      return {
        status: 'unhealthy',
        responseTime,
        details: { error: error.message }
      };
    }
    
    return {
      status: responseTime < 1000 ? 'healthy' : 'degraded',
      responseTime,
      details: { connectionPool: 'active' }
    };
    
  } catch (error) {
    return {
      status: 'unhealthy',
      responseTime: Date.now() - startTime,
      details: { error: error instanceof Error ? error.message : 'Unknown error' }
    };
  }
}

async function checkLineApiHealth(): Promise<ServiceHealth> {
  const startTime = Date.now();
  
  try {
    // LINE API„ÅÆÁ∞°Âçò„Å™Êé•Á∂öÁ¢∫Ë™ç
    const response = await fetch('https://api.line.me/v2/bot/info', {
      headers: {
        'Authorization': `Bearer ${process.env.LINE_MESSAGING_ACCESS_TOKEN}`
      }
    });
    
    const responseTime = Date.now() - startTime;
    
    return {
      status: response.ok ? 'healthy' : 'degraded',
      responseTime,
      details: { 
        httpStatus: response.status,
        rateLimitRemaining: response.headers.get('X-Line-Request-Id')
      }
    };
    
  } catch (error) {
    return {
      status: 'unhealthy',
      responseTime: Date.now() - startTime,
      details: { error: error instanceof Error ? error.message : 'Unknown error' }
    };
  }
}

function checkMemoryHealth(): ServiceHealth {
  const memoryUsage = process.memoryUsage();
  const heapUsedMB = Math.round(memoryUsage.heapUsed / 1024 / 1024);
  const heapTotalMB = Math.round(memoryUsage.heapTotal / 1024 / 1024);
  
  // „É°„É¢„É™‰ΩøÁî®Áéá„Åå80%„ÇíË∂Ö„Åà„Åü„ÇâË≠¶Âëä
  const usageRatio = memoryUsage.heapUsed / memoryUsage.heapTotal;
  
  return {
    status: usageRatio < 0.8 ? 'healthy' : usageRatio < 0.9 ? 'degraded' : 'unhealthy',
    details: {
      heapUsedMB,
      heapTotalMB,
      usageRatio: Math.round(usageRatio * 100)
    }
  };
}
```

## üîí **„Çª„Ç≠„É•„É™„ÉÜ„Ç£‰ªïÊßò**

### **1. Ë™çË®º„ÉªË™çÂèØ**

#### **ÁÆ°ÁêÜËÄÖË™çË®º**
```typescript
// „Éë„Çπ„ÉØ„Éº„Éâ„Éè„ÉÉ„Ç∑„É•Âåñ
import bcrypt from 'bcrypt';

const SALT_ROUNDS = 12;
const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || 'admin123';

export async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, SALT_ROUNDS);
}

export async function verifyPassword(password: string, hash: string): Promise<boolean> {
  return bcrypt.compare(password, hash);
}

// „Çª„ÉÉ„Ç∑„Éß„É≥ÁÆ°ÁêÜ
interface AdminSession {
  id: string;
  userId: string;
  createdAt: Date;
  expiresAt: Date;
  ipAddress: string;
  userAgent: string;
}

class SessionManager {
  private sessions = new Map<string, AdminSession>();
  private readonly SESSION_DURATION = 24 * 60 * 60 * 1000; // 24ÊôÇÈñì
  
  createSession(userId: string, ipAddress: string, userAgent: string): string {
    const sessionId = crypto.randomUUID();
    const now = new Date();
    
    const session: AdminSession = {
      id: sessionId,
      userId,
      createdAt: now,
      expiresAt: new Date(now.getTime() + this.SESSION_DURATION),
      ipAddress,
      userAgent
    };
    
    this.sessions.set(sessionId, session);
    
    // ÊúüÈôêÂàá„Çå„Çª„ÉÉ„Ç∑„Éß„É≥„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
    this.cleanupExpiredSessions();
    
    return sessionId;
  }
  
  validateSession(sessionId: string): AdminSession | null {
    const session = this.sessions.get(sessionId);
    
    if (!session || session.expiresAt < new Date()) {
      if (session) {
        this.sessions.delete(sessionId);
      }
      return null;
    }
    
    return session;
  }
  
  revokeSession(sessionId: string): void {
    this.sessions.delete(sessionId);
  }
  
  private cleanupExpiredSessions(): void {
    const now = new Date();
    for (const [id, session] of this.sessions.entries()) {
      if (session.expiresAt < now) {
        this.sessions.delete(id);
      }
    }
  }
}

export const sessionManager = new SessionManager();
```

#### **„É¨„Éº„ÉàÂà∂Èôê**
```typescript
interface RateLimitConfig {
  windowMs: number;
  maxRequests: number;
  skipSuccessfulRequests?: boolean;
  skipFailedRequests?: boolean;
}

class RateLimiter {
  private requests = new Map<string, number[]>();
  
  constructor(private config: RateLimitConfig) {}
  
  isAllowed(identifier: string): boolean {
    const now = Date.now();
    const windowStart = now - this.config.windowMs;
    
    // Êó¢Â≠ò„ÅÆ„É™„ÇØ„Ç®„Çπ„ÉàÂ±•Ê≠¥„ÇíÂèñÂæó
    const requestTimes = this.requests.get(identifier) || [];
    
    // „Ç¶„Ç£„É≥„Éâ„Ç¶Â§ñ„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„ÇíÂâäÈô§
    const validRequests = requestTimes.filter(time => time > windowStart);
    
    // Âà∂Èôê„ÉÅ„Çß„ÉÉ„ÇØ
    if (validRequests.length >= this.config.maxRequests) {
      return false;
    }
    
    // Êñ∞„Åó„ÅÑ„É™„ÇØ„Ç®„Çπ„Éà„ÇíË®òÈå≤
    validRequests.push(now);
    this.requests.set(identifier, validRequests);
    
    return true;
  }
  
  getRemainingRequests(identifier: string): number {
    const now = Date.now();
    const windowStart = now - this.config.windowMs;
    const requestTimes = this.requests.get(identifier) || [];
    const validRequests = requestTimes.filter(time => time > windowStart);
    
    return Math.max(0, this.config.maxRequests - validRequests.length);
  }
  
  getResetTime(identifier: string): number {
    const requestTimes = this.requests.get(identifier) || [];
    if (requestTimes.length === 0) return 0;
    
    const oldestRequest = Math.min(...requestTimes);
    return oldestRequest + this.config.windowMs;
  }
}

// APIÂà•„É¨„Éº„ÉàÂà∂ÈôêË®≠ÂÆö
export const rateLimiters = {
  general: new RateLimiter({ windowMs: 15 * 60 * 1000, maxRequests: 100 }), // 15ÂàÜ„Åß100„É™„ÇØ„Ç®„Çπ„Éà
  reservation: new RateLimiter({ windowMs: 60 * 1000, maxRequests: 5 }),     // 1ÂàÜ„Åß5„É™„ÇØ„Ç®„Çπ„Éà
  admin: new RateLimiter({ windowMs: 60 * 1000, maxRequests: 30 }),          // 1ÂàÜ„Åß30„É™„ÇØ„Ç®„Çπ„Éà
  import: new RateLimiter({ windowMs: 60 * 1000, maxRequests: 2 })           // 1ÂàÜ„Åß2„É™„ÇØ„Ç®„Çπ„Éà
};
```

### **2. „Éá„Éº„Çø‰øùË≠∑**

#### **ÂÖ•ÂäõÂÄ§„Çµ„Éã„Çø„Ç§„Çº„Éº„Ç∑„Éß„É≥**
```typescript
import DOMPurify from 'isomorphic-dompurify';

export function sanitizeInput(input: string): string {
  // HTML„Çø„Ç∞„ÅÆÈô§Âéª
  const cleaned = DOMPurify.sanitize(input, { ALLOWED_TAGS: [] });
  
  // Âà∂Âæ°ÊñáÂ≠ó„ÅÆÈô§Âéª
  return cleaned.replace(/[\x00-\x1F\x7F]/g, '');
}

export function sanitizePhoneNumber(phone: string): string {
  // ÈõªË©±Áï™Âè∑„ÅÆÊ≠£Ë¶èÂåñÔºàÊï∞Â≠ó„ÄÅ„Éè„Ç§„Éï„É≥„ÄÅÊã¨Âºß„ÅÆ„ÅøË®±ÂèØÔºâ
  return phone.replace(/[^0-9\-()]/g, '');
}

export function sanitizeEmail(email: string): string {
  // „É°„Éº„É´„Ç¢„Éâ„É¨„Çπ„ÅÆÂü∫Êú¨ÁöÑ„Å™„Çµ„Éã„Çø„Ç§„Çº„Éº„Ç∑„Éß„É≥
  return email.toLowerCase().trim();
}
```

#### **„Éá„Éº„ÇøÊöóÂè∑Âåñ**
```typescript
import crypto from 'crypto';

const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || crypto.randomBytes(32);
const ALGORITHM = 'aes-256-gcm';

export function encrypt(text: string): string {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipher(ALGORITHM, ENCRYPTION_KEY);
  
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  const authTag = cipher.getAuthTag();
  
  return iv.toString('hex') + ':' + authTag.toString('hex') + ':' + encrypted;
}

export function decrypt(encryptedData: string): string {
  const parts = encryptedData.split(':');
  const iv = Buffer.from(parts[0], 'hex');
  const authTag = Buffer.from(parts[1], 'hex');
  const encrypted = parts[2];
  
  const decipher = crypto.createDecipher(ALGORITHM, ENCRYPTION_KEY);
  decipher.setAuthTag(authTag);
  
  let decrypted = decipher.update(encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
}
```

## üîÑ **„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„ÉªÂæ©Êóß**

### **1. „Éá„Éº„Çø„Éô„Éº„Çπ„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó**

#### **Ëá™Âãï„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóË®≠ÂÆö**
```sql
-- Supabase„ÅÆËá™Âãï„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóË®≠ÂÆö
-- Êó•Ê¨°„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÔºà7Êó•Èñì‰øùÊåÅÔºâ
-- ÈÄ±Ê¨°„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÔºà4ÈÄ±Èñì‰øùÊåÅÔºâ
-- ÊúàÊ¨°„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÔºà12„É∂Êúà‰øùÊåÅÔºâ

-- ÊâãÂãï„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„Çπ„ÇØ„É™„Éó„Éà
-- pg_dump „Çí‰ΩøÁî®„Åó„Åü„Éï„É´„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó
pg_dump -h your-host -U postgres -d your-database > backup_$(date +%Y%m%d_%H%M%S).sql

-- „ÉÜ„Éº„Éñ„É´Âà•„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó
pg_dump -h your-host -U postgres -d your-database -t products > products_backup.sql
pg_dump -h your-host -U postgres -d your-database -t reservations > reservations_backup.sql
```

#### **Âæ©ÊóßÊâãÈ†Ü**
```bash
# 1. „Éá„Éº„Çø„Éô„Éº„ÇπÂæ©Êóß
psql -h your-host -U postgres -d your-database < backup_file.sql

# 2. „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÂÜçËµ∑Âãï
vercel --prod

# 3. „Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØÁ¢∫Ë™ç
curl https://your-domain.com/api/health

# 4. Ê©üËÉΩ„ÉÜ„Çπ„ÉàÂÆüË°å
npm run test:e2e
```

### **2. ÁÅΩÂÆ≥Âæ©ÊóßË®àÁîª**

#### **RTO/RPOÁõÆÊ®ô**
- **RTO (Recovery Time Objective)**: 4ÊôÇÈñì‰ª•ÂÜÖ
- **RPO (Recovery Point Objective)**: 1ÊôÇÈñì‰ª•ÂÜÖ

#### **Âæ©ÊóßÊâãÈ†ÜÊõ∏**
```markdown
## ÁÅΩÂÆ≥Âæ©ÊóßÊâãÈ†Ü

### Phase 1: Áä∂Ê≥ÅÁ¢∫Ë™çÔºà15ÂàÜ‰ª•ÂÜÖÔºâ
1. „Ç∑„Çπ„ÉÜ„É†Áä∂ÊÖã„ÅÆÁ¢∫Ë™ç
2. ÂΩ±ÈüøÁØÑÂõ≤„ÅÆÁâπÂÆö
3. Èñ¢‰øÇËÄÖ„Å∏„ÅÆÈÄ£Áµ°

### Phase 2: Á∑äÊÄ•ÂØæÂøúÔºà1ÊôÇÈñì‰ª•ÂÜÖÔºâ
1. „Çµ„Éº„Éì„ÇπÂÅúÊ≠¢„ÅÆÂëäÁü•
2. „Éá„Éº„Çø„Éô„Éº„Çπ„ÅÆÁä∂ÊÖãÁ¢∫Ë™ç
3. „Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„ÅÆÁ¢∫Ë™ç

### Phase 3: Âæ©Êóß‰ΩúÊ•≠Ôºà3ÊôÇÈñì‰ª•ÂÜÖÔºâ
1. „Éá„Éº„Çø„Éô„Éº„ÇπÂæ©Êóß
2. „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Âæ©Êóß
3. Ê©üËÉΩ„ÉÜ„Çπ„ÉàÂÆüË°å

### Phase 4: „Çµ„Éº„Éì„ÇπÂÜçÈñãÔºà4ÊôÇÈñì‰ª•ÂÜÖÔºâ
1. ÂÖ®Ê©üËÉΩ„ÅÆÂãï‰ΩúÁ¢∫Ë™ç
2. „Çµ„Éº„Éì„ÇπÂÜçÈñã„ÅÆÂëäÁü•
3. Áõ£Ë¶ñ‰ΩìÂà∂„ÅÆÂº∑Âåñ
```