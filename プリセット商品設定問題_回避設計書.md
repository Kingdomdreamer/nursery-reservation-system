# プリセット商品設定問題 回避設計書

## 📋 事象概要

### 現在発生している問題
1. **プリセット商品の設定が反映されない**
   - 管理画面でプリセットを作成し、商品一覧から該当プリセットに紐づく商品を選択・保存
   - プレビュー画面に遷移すると、「商品選択」欄に選択済みの商品が一切表示されない
   - 常に「現在選択できません」とだけ表示される

2. **API エンドポイントの 404 エラー**
   - ブラウザのネットワークタブで確認すると、`GET /api/admin/preset-products/{presetId}` が本番デプロイ環境で 404 になる
   - ローカルでは同エンドポイントが正常に 200 レスポンスを返す
   - デプロイ側のキャッシュや設定に問題の可能性

3. **React のレンダリングエラー（Minified React error #418）**
   - フロントエンドのコンソールに繰り返しエラーが出力される
   - JSXにオブジェクトが直接レンダリングされることが原因

## 🎯 設計方針

### 基本原則
1. **フェイルセーフ設計**: エラー時でも最低限の機能を提供
2. **段階的フォールバック**: 複数のデータ取得経路を用意
3. **型安全性の徹底**: TypeScriptによる厳密な型チェック
4. **デバッグ可能性**: 問題特定のための詳細ログ

### アーキテクチャ方針
- **API First**: フロントエンドは必ずAPI経由でデータ取得
- **エラー境界**: コンポーネントレベルでのエラーハンドリング
- **状態管理**: 明確な状態遷移とエラー状態の管理

## 🔧 技術的解決策

### 1. API ルート修正（最優先）

#### 問題の根本原因
- Next.js 15での動的ルートパラメータの処理方法変更
- `context.params` の非同期処理が不適切

#### 修正内容
```typescript
// src/app/api/admin/preset-products/[presetId]/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { supabaseAdmin } from '@/lib/supabase';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ presetId: string }> }
) {
  try {
    // パラメータの安全な取得
    const { presetId } = await params;
    const id = Number(presetId);
    
    // バリデーション
    if (Number.isNaN(id) || id < 1) {
      console.error(`Invalid presetId: ${presetId}`);
      return NextResponse.json(
        { 
          error: '無効なプリセットIDです',
          code: 'INVALID_PRESET_ID',
          presetId 
        },
        { status: 400 }
      );
    }

    // Supabase接続確認
    if (!supabaseAdmin) {
      console.error('Supabase admin client not available');
      return NextResponse.json(
        { 
          error: 'データベース接続エラー',
          code: 'DB_CONNECTION_ERROR' 
        },
        { status: 500 }
      );
    }

    console.log(`Fetching preset products for presetId: ${id}`);

    // プリセット商品データの取得
    const { data: presetProducts, error: dbError } = await supabaseAdmin
      .from('preset_products')
      .select(`
        product_id,
        display_order,
        is_active,
        product:products(
          id,
          name,
          price,
          category_id,
          visible,
          created_at,
          updated_at
        )
      `)
      .eq('preset_id', id)
      .eq('is_active', true)
      .order('display_order');

    if (dbError) {
      console.error('Database query error:', dbError);
      return NextResponse.json(
        { 
          error: 'データベースクエリエラー',
          code: 'DB_QUERY_ERROR',
          details: dbError.message 
        },
        { status: 500 }
      );
    }

    // データの整形と検証
    const validProducts = (presetProducts || [])
      .filter(pp => {
        // 商品データの存在確認
        if (!pp.product) {
          console.warn(`Product not found for product_id: ${pp.product_id}`);
          return false;
        }
        
        // 商品の可視性確認
        if (!pp.product.visible) {
          console.warn(`Product not visible: ${pp.product.id}`);
          return false;
        }
        
        return true;
      })
      .map(pp => ({
        ...pp.product,
        display_order: pp.display_order,
        preset_product_id: pp.product_id
      }))
      .sort((a, b) => (a.display_order || 999) - (b.display_order || 999));

    console.log(`Found ${validProducts.length} valid products for preset ${id}`);

    return NextResponse.json({
      success: true,
      data: validProducts,
      meta: {
        presetId: id,
        totalCount: validProducts.length,
        timestamp: new Date().toISOString()
      }
    });

  } catch (error) {
    console.error('Unexpected error in preset-products API:', error);
    return NextResponse.json(
      { 
        error: '予期しないエラーが発生しました',
        code: 'UNEXPECTED_ERROR',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ presetId: string }> }
) {
  try {
    const { presetId } = await params;
    const id = Number(presetId);
    
    if (Number.isNaN(id) || id < 1) {
      return NextResponse.json(
        { error: '無効なプリセットIDです' },
        { status: 400 }
      );
    }

    if (!supabaseAdmin) {
      return NextResponse.json(
        { error: 'データベース接続エラー' },
        { status: 500 }
      );
    }

    const updates = await request.json();
    
    // データの検証
    if (!Array.isArray(updates)) {
      return NextResponse.json(
        { error: '更新データの形式が正しくありません' },
        { status: 400 }
      );
    }

    // 更新処理
    const { error: updateError } = await supabaseAdmin
      .from('preset_products')
      .upsert(
        updates.map((update: any) => ({
          preset_id: id,
          ...update
        }))
      );

    if (updateError) {
      console.error('Update error:', updateError);
      return NextResponse.json(
        { error: '更新に失敗しました', details: updateError.message },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      message: '更新が完了しました'
    });

  } catch (error) {
    console.error('PUT error:', error);
    return NextResponse.json(
      { error: '予期しないエラーが発生しました' },
      { status: 500 }
    );
  }
}
```

### 2. React Error #418 対策

#### 安全なレンダリング関数の実装
```typescript
// src/lib/utils/safeRender.ts

/**
 * React Error #418 対策用の安全なレンダリング関数群
 */

export const safeRender = (value: unknown): string => {
  if (value === null || value === undefined) return '';
  if (typeof value === 'string') return value;
  if (typeof value === 'number') return String(value);
  if (typeof value === 'boolean') return value ? 'true' : 'false';
  
  // オブジェクトの場合は安全に文字列化
  if (typeof value === 'object') {
    try {
      // 循環参照対策
      return JSON.stringify(value, null, 2);
    } catch (error) {
      console.warn('Failed to stringify object:', error);
      return '[Object]';
    }
  }
  
  return String(value);
};

export const safeProductName = (product: unknown): string => {
  if (!product || typeof product !== 'object') {
    console.warn('Invalid product data:', product);
    return '商品名不明';
  }
  
  const productObj = product as Record<string, unknown>;
  
  if (typeof productObj.name === 'string' && productObj.name.trim()) {
    return productObj.name.trim();
  }
  
  if (typeof productObj.product_name === 'string' && productObj.product_name.trim()) {
    return productObj.product_name.trim();
  }
  
  console.warn('Product name not found in:', productObj);
  return '商品名不明';
};

export const safePrice = (price: unknown): string => {
  if (typeof price === 'number' && !isNaN(price) && price >= 0) {
    return `¥${price.toLocaleString()}`;
  }
  
  if (typeof price === 'string') {
    const numPrice = parseFloat(price);
    if (!isNaN(numPrice) && numPrice >= 0) {
      return `¥${numPrice.toLocaleString()}`;
    }
  }
  
  console.warn('Invalid price data:', price);
  return '価格不明';
};

export const safeQuantity = (quantity: unknown): number => {
  if (typeof quantity === 'number' && !isNaN(quantity) && quantity >= 0) {
    return Math.floor(quantity);
  }
  
  if (typeof quantity === 'string') {
    const numQuantity = parseInt(quantity, 10);
    if (!isNaN(numQuantity) && numQuantity >= 0) {
      return numQuantity;
    }
  }
  
  console.warn('Invalid quantity data:', quantity);
  return 0;
};

// 型ガード関数
export const isValidProduct = (product: unknown): product is {
  id: number;
  name: string;
  price: number;
} => {
  return (
    typeof product === 'object' &&
    product !== null &&
    typeof (product as any).id === 'number' &&
    typeof (product as any).name === 'string' &&
    typeof (product as any).price === 'number'
  );
};
```

### 3. フロントエンド修正

#### ProductSelectionSection の完全リファクタリング
```typescript
// src/components/features/reservation/ProductSelectionSection.tsx

import React, { useMemo, useCallback, useState, useEffect } from 'react';
import { useFormContext } from 'react-hook-form';
import { Button } from '@/components/ui';
import type { Product, PickupWindow, FormSettings } from '@/types';
import type { ReservationFormData, ProductSelectionData } from '@/lib/validations/reservationSchema';
import { getCategoryName } from '@/lib/utils';
import { 
  safeRender, 
  safeProductName, 
  safePrice, 
  safeQuantity,
  isValidProduct 
} from '@/lib/utils/safeRender';

export interface ProductSelectionSectionProps {
  products: Product[];
  pickupWindows: PickupWindow[];
  formSettings: FormSettings;
  className?: string;
}

// エラー境界コンポーネント
class ProductSelectionErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean; error?: Error }
> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('ProductSelection Error Boundary caught an error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4">
          <h3 className="text-red-800 font-medium mb-2">商品選択でエラーが発生しました</h3>
          <p className="text-red-700 text-sm mb-3">
            {this.state.error?.message || '予期しないエラーが発生しました'}
          </p>
          <button
            onClick={() => {
              this.setState({ hasError: false, error: undefined });
              window.location.reload();
            }}
            className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
          >
            ページを再読み込み
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

export const ProductSelectionSection = React.memo<ProductSelectionSectionProps>(({
  products,
  pickupWindows,
  formSettings,
  className,
}) => {
  const { setValue, watch, formState: { errors } } = useFormContext<ReservationFormData>();
  
  const selectedProducts = watch('products') || [];
  const [isClient, setIsClient] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [debugInfo, setDebugInfo] = useState<any>(null);

  // クライアントサイドハイドレーション対応
  useEffect(() => {
    setIsClient(true);
    
    // デバッグ情報の設定
    setDebugInfo({
      productsType: typeof products,
      productsIsArray: Array.isArray(products),
      productsLength: products?.length || 0,
      formSettingsExists: !!formSettings,
      timestamp: new Date().toISOString()
    });
  }, [products, formSettings]);

  // 商品データの安全な処理
  const safeProducts = useMemo(() => {
    if (!isClient) {
      console.log('[ProductSelection] Client not ready');
      return [];
    }
    
    console.log('[ProductSelection] Processing products:', {
      type: typeof products,
      isArray: Array.isArray(products),
      length: products?.length || 0,
      data: products
    });
    
    if (!products) {
      setError('商品データが取得できませんでした。管理画面でプリセット設定を確認してください。');
      return [];
    }
    
    if (!Array.isArray(products)) {
      setError(`商品データの形式が正しくありません。期待値: 配列, 実際: ${typeof products}`);
      return [];
    }
    
    if (products.length === 0) {
      setError('このプリセットには商品が設定されていません。管理画面で商品を追加してください。');
      return [];
    }
    
    // 商品データの検証とフィルタリング
    const validProducts = products.filter((product, index) => {
      if (!isValidProduct(product)) {
        console.warn(`[ProductSelection] Invalid product at index ${index}:`, product);
        return false;
      }
      return true;
    });
    
    if (validProducts.length === 0) {
      setError('有効な商品データが見つかりませんでした。商品データの形式を確認してください。');
      return [];
    }
    
    console.log(`[ProductSelection] Processed ${validProducts.length} valid products`);
    setError(null);
    return validProducts;
  }, [products, isClient]);

  // 商品のカテゴリ別グループ化
  const groupedProducts = useMemo(() => {
    return safeProducts.reduce((groups, product) => {
      const categoryId = product.category_id || 0;
      if (!groups[categoryId]) {
        groups[categoryId] = [];
      }
      groups[categoryId].push(product);
      return groups;
    }, {} as Record<number, Product[]>);
  }, [safeProducts]);

  // 合計金額の計算
  const totalAmount = useMemo(() => {
    return selectedProducts.reduce((sum, product) => {
      const quantity = safeQuantity(product.quantity);
      const price = typeof product.unit_price === 'number' ? product.unit_price : 0;
      return sum + (quantity * price);
    }, 0);
  }, [selectedProducts]);

  // 商品の選択数量取得
  const getProductQuantity = useCallback((productId: number): number => {
    const product = selectedProducts.find(p => p.product_id === productId);
    return safeQuantity(product?.quantity);
  }, [selectedProducts]);

  // 数量変更ハンドラー
  const handleQuantityChange = useCallback((productId: number, quantity: number) => {
    try {
      const product = safeProducts.find(p => p.id === productId);
      if (!product) {
        console.error(`Product not found: ${productId}`);
        return;
      }

      const safeQty = Math.max(0, Math.min(99, Math.floor(quantity)));
      const existingIndex = selectedProducts.findIndex(p => p.product_id === productId);
      const newSelectedProducts = [...selectedProducts];

      if (safeQty === 0) {
        // 商品を削除
        if (existingIndex >= 0) {
          newSelectedProducts.splice(existingIndex, 1);
        }
      } else {
        // 商品を追加または更新
        const productSelection: ProductSelectionData = {
          product_id: product.id,
          product_name: safeProductName(product),
          quantity: safeQty,
          unit_price: product.price || 0,
          total_price: (product.price || 0) * safeQty,
          category: product.category_id?.toString(),
        };

        if (existingIndex >= 0) {
          newSelectedProducts[existingIndex] = productSelection;
        } else {
          newSelectedProducts.push(productSelection);
        }
      }

      setValue('products', newSelectedProducts);
      console.log(`[ProductSelection] Updated quantity for product ${productId}: ${safeQty}`);
    } catch (error) {
      console.error('Error in handleQuantityChange:', error);
      setError('商品の数量変更中にエラーが発生しました');
    }
  }, [safeProducts, selectedProducts, setValue]);

  // 数量コントロールコンポーネント
  const QuantityControl = React.memo<{ 
    productId: number;
    quantity: number;
  }>(({ productId, quantity }) => (
    <div className="flex items-center space-x-3">
      <Button
        type="button"
        variant="outline"
        size="icon"
        onClick={() => handleQuantityChange(productId, quantity - 1)}
        disabled={quantity === 0}
        className="h-8 w-8 rounded-full"
      >
        −
      </Button>
      
      <span className="w-8 text-center font-medium text-sm">
        {safeRender(quantity)}
      </span>
      
      <Button
        type="button"
        variant="outline"
        size="icon"
        onClick={() => handleQuantityChange(productId, quantity + 1)}
        disabled={quantity >= 99}
        className="h-8 w-8 rounded-full"
      >
        +
      </Button>
    </div>
  ));

  QuantityControl.displayName = 'QuantityControl';

  // クライアントサイド準備前の表示
  if (!isClient) {
    return (
      <div className={className}>
        <h2 className="text-lg font-semibold text-gray-900 border-b pb-2 mb-4">
          商品選択
        </h2>
        <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
          <div className="animate-pulse">
            <div className="h-4 bg-gray-300 rounded w-3/4 mb-2"></div>
            <div className="h-4 bg-gray-300 rounded w-1/2"></div>
          </div>
          <p className="text-sm text-gray-600 mt-2">
            商品情報を読み込み中...
          </p>
        </div>
      </div>
    );
  }

  // エラー表示
  if (error) {
    return (
      <div className={className}>
        <h2 className="text-lg font-semibold text-gray-900 border-b pb-2 mb-4">
          商品選択
        </h2>
        <div className="bg-red-50 border border-red-200 rounded-lg p-4">
          <div className="flex items-start">
            <div className="flex-shrink-0">
              <svg className="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
              </svg>
            </div>
            <div className="ml-3">
              <h3 className="text-sm font-medium text-red-800">
                商品選択でエラーが発生しました
              </h3>
              <p className="text-sm text-red-700 mt-1">
                {safeRender(error)}
              </p>
              <div className="mt-3">
                <button
                  onClick={() => {
                    setError(null);
                    window.location.reload();
                  }}
                  className="text-sm bg-red-600 text-white px-3 py-1 rounded hover:bg-red-700"
                >
                  ページを再読み込み
                </button>
              </div>
              
              {/* デバッグ情報（開発環境のみ） */}
              {process.env.NODE_ENV === 'development' && debugInfo && (
                <details className="mt-3">
                  <summary className="text-xs text-red-600 cursor-pointer">
                    デバッグ情報を表示
                  </summary>
                  <pre className="text-xs text-red-600 mt-2 bg-red-100 p-2 rounded overflow-auto">
                    {safeRender(debugInfo)}
                  </pre>
                </details>
              )}
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <ProductSelectionErrorBoundary>
      <div className={className}>
        <h2 className="text-lg font-semibold text-gray-900 border-b pb-2 mb-4">
          商品選択
        </h2>

        {/* 選択済み商品サマリー */}
        {selectedProducts.length > 0 && (
          <div className="mb-6 bg-green-50 border border-green-200 rounded-lg p-4">
            <h3 className="font-medium text-gray-900 mb-3">選択した商品</h3>
            <div className="space-y-2">
              {selectedProducts.map((product) => (
                <div key={product.product_id} className="flex justify-between items-center text-sm">
                  <span>
                    {safeRender(product.product_name)} × {safeRender(product.quantity)}
                  </span>
                  <div className="flex items-center space-x-2">
                    {formSettings?.show_price && (
                      <span className="font-medium">
                        {safePrice(product.total_price)}
                      </span>
                    )}
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => handleQuantityChange(product.product_id, 0)}
                      className="text-xs h-6 px-2"
                    >
                      削除
                    </Button>
                  </div>
                </div>
              ))}
              
              {formSettings?.show_price && (
                <div className="pt-2 border-t border-green-300 flex justify-between items-center font-medium">
                  <span>合計金額</span>
                  <span className="text-lg text-green-700">
                    {safePrice(totalAmount)}
                  </span>
                </div>
              )}
            </div>
          </div>
        )}

        {/* 商品一覧 */}
        <div className="space-y-6">
          <p className="text-sm text-gray-600">
            ご希望の商品とそれぞれの数量を選択してください
          </p>
          
          {Object.entries(groupedProducts).map(([categoryIdStr, categoryProducts]) => {
            const categoryId = parseInt(categoryIdStr, 10);
            
            return (
              <div key={categoryId} className="space-y-3">
                <h3 className="text-md font-medium text-gray-800 border-l-4 border-green-500 pl-3">
                  {getCategoryName(categoryId)}
                </h3>
                
                <div className="grid gap-3">
                  {categoryProducts.map((product) => {
                    const quantity = getProductQuantity(product.id);
                    
                    return (
                      <div
                        key={product.id}
                        className={`border rounded-lg p-4 transition-colors ${
                          quantity > 0 
                            ? 'bg-green-50 border-green-200' 
                            : 'bg-white border-gray-200 hover:border-green-300'
                        }`}
                      >
                        <div className="flex justify-between items-center">
                          <div className="flex-1">
                            <h4 className="font-medium text-gray-900">
                              {safeRender(product.name)}
                            </h4>
                            {formSettings?.show_price && (
                              <p className="text-sm text-gray-600">
                                {safePrice(product.price)}
                              </p>
                            )}
                          </div>
                          
                          <QuantityControl
                            productId={product.id}
                            quantity={quantity}
                          />
                        </div>
                        
                        {quantity > 0 && formSettings?.show_price && (
                          <div className="mt-2 pt-2 border-t border-gray-200">
                            <p className="text-sm text-gray-700">
                              小計: {safePrice((product.price || 0) * quantity)}
                            </p>
                          </div>
                        )}
                      </div>
                    );
                  })}
                </div>
              </div>
            );
          })}
        </div>

        {/* バリデーションエラー */}
        {errors.products && (
          <div className="mt-4 bg-red-50 border border-red-200 rounded-lg p-3">
            <p className="text-sm text-red-600">
              {safeRender(errors.products.message)}
            </p>
          </div>
        )}

        {/* ヘルプテキスト */}
        <div className="mt-4 text-xs text-gray-500 bg-gray-50 p-3 rounded-lg">
          <p>• 数量は最大99個まで選択できます</p>
          <p>• 選択した商品は上部に表示され、「削除」ボタンで取り消せます</p>
          <p>• 引き取り日は選択した商品カテゴリによって決まります</p>
        </div>
      </div>
    </ProductSelectionErrorBoundary>
  );
});

ProductSelectionSection.displayName = 'ProductSelectionSection';
```

### 4. データ取得フック修正

#### useFormConfig の強化
```typescript
// src/hooks/useFormConfig.ts

import { useState, useEffect, useCallback } from 'react';
import type { FormConfigResponse } from '@/types';

export interface UseFormConfigOptions {
  enabled?: boolean;
  onError?: (error: string) => void;
  retryCount?: number;
  retryDelay?: number;
}

export interface UseFormConfigReturn {
  config: FormConfigResponse | null;
  loading: boolean;
  error: string | null;
  refetch: () => Promise<void>;
  debugInfo: any;
}

export const useFormConfig = (
  presetId: number,
  options: UseFormConfigOptions = {}
): UseFormConfigReturn => {
  const { 
    enabled = true, 
    onError, 
    retryCount = 3, 
    retryDelay = 1000 
  } = options;
  
  const [config, setConfig] = useState<FormConfigResponse | null>(null);
  const [loading, setLoading] = useState(enabled);
  const [error, setError] = useState<string | null>(null);
  const [debugInfo, setDebugInfo] = useState<any>(null);
  const [retryAttempt, setRetryAttempt] = useState(0);

  const fetchConfig = useCallback(async (attempt = 0) => {
    if (!enabled || presetId < 1) {
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      setError(null);
      
      const startTime = Date.now();
      console.log(`[useFormConfig] Fetching config for preset: ${presetId} (attempt ${attempt + 1})`);
      
      // API呼び出し
      const response = await fetch(`/api/form/${presetId}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Cache-Control': 'no-cache',
        },
      });
      
      const endTime = Date.now();
      const responseTime = endTime - startTime;
      
      console.log(`[useFormConfig] API response:`, {
        status: response.status,
        statusText: response.statusText,
        responseTime: `${responseTime}ms`,
        headers: Object.fromEntries(response.headers.entries())
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`[useFormConfig] API error response:`, {
          status: response.status,
          statusText: response.statusText,
          body: errorText
        });
        
        throw new Error(`API error: ${response.status} ${response.statusText}`);
      }
      
      const result = await response.json();
      
      console.log(`[useFormConfig] API result:`, {
        success: result.success,
        hasData: !!result.data,
        productsCount: result.data?.products?.length || 0,
        formSettingsExists: !!result.data?.form_settings,
        presetExists: !!result.data?.preset
      });
      
      if (!result.success || !result.data) {
        throw new Error('フォーム設定の読み込みに失敗しました');
      }
      
      // デバッグ情報の更新
      setDebugInfo({
        presetId,
        responseTime,
        attempt: attempt + 1,
        timestamp: new Date().toISOString(),
        apiResponse: {
          success: result.success,
          dataKeys: result.data ? Object.keys(result.data) : [],
          productsCount: result.data?.products?.length || 0
        }
      });
      
      setConfig(result.data);
      setRetryAttempt(0);
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'エラーが発生しました';
      console.error(`[useFormConfig] Fetch error (attempt ${attempt + 1}):`, err);
      
      // リトライロジック
      if (attempt < retryCount - 1) {
        console.log(`[useFormConfig] Retrying in ${retryDelay}ms...`);
        setRetryAttempt(attempt + 1);
        
        setTimeout(() => {
          fetchConfig(attempt + 1);
        }, retryDelay * (attempt + 1)); // 指数バックオフ
        
        return;
      }
      
      // 最終的なエラー処理
      setError(errorMessage);
      setDebugInfo({
        presetId,
        error: errorMessage,
        attempt: attempt + 1,
        timestamp: new Date().toISOString(),
        finalAttempt: true
      });
      
      onError?.(errorMessage);
    } finally {
      if (attempt === retryCount - 1 || !error) {
        setLoading(false);
      }
    }
  }, [presetId, enabled, onError, retryCount, retryDelay]);

  const refetch = useCallback(async () => {
    setRetryAttempt(0);
    await fetchConfig(0);
  }, [fetchConfig]);

  useEffect(() => {
    if (enabled) {
      fetchConfig(0);
    }
  }, [fetchConfig, enabled]);

  return {
    config,
    loading,
    error,
    refetch,
    debugInfo
  };
};
```

## 🔍 デバッグ・監視機能

### 1. 詳細ログシステム
```typescript
// src/lib/utils/logger.ts

export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3
}

export class Logger {
  private static instance: Logger;
  private logLevel: LogLevel = LogLevel.INFO;

  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  setLogLevel(level: LogLevel) {
    this.logLevel = level;
  }

  private log(level: LogLevel, message: string, data?: any) {
    if (level < this.logLevel) return;

    const timestamp = new Date().toISOString();
    const levelName = LogLevel[level];
    const prefix = `[${timestamp}] [${levelName}]`;

    switch (level) {
      case LogLevel.DEBUG:
        console.debug(prefix, message, data);
        break;
      case LogLevel.INFO:
        console.info(prefix, message, data);
        break;
      case LogLevel.WARN:
        console.warn(prefix, message, data);
        break;
      case LogLevel.ERROR:
        console.error(prefix, message, data);
        break;
    }
  }

  debug(message: string, data?: any) {
    this.log(LogLevel.DEBUG, message, data);
  }

  info(message: string, data?: any) {
    this.log(LogLevel.INFO, message, data);
  }

  warn(message: string, data?: any) {
    this.log(LogLevel.WARN, message, data);
  }

  error(message: string, data?: any) {
    this.log(LogLevel.ERROR, message, data);
  }
}

export const logger = Logger.getInstance();
```

### 2. エラー監視コンポーネント
```typescript
// src/components/ErrorMonitor.tsx

import React, { useEffect } from 'react';
import { logger } from '@/lib/utils/logger';

export const ErrorMonitor: React.FC = () => {
  useEffect(() => {
    // グローバルエラーハンドラー
    const handleError = (event: ErrorEvent) => {
      logger.error('Global error caught:', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        error: event.error
      });
    };

    // Promise rejection ハンドラー
    const handleUnhandledRejection = (event: PromiseRejectionEvent) => {
      logger.error('Unhandled promise rejection:', {
        reason: event.reason,
        promise: event.promise
      });
    };

    window.addEventListener('error', handleError);
    window.addEventListener('unhandledrejection', handleUnhandledRejection);

    return () => {
      window.removeEventListener('error', handleError);
      window.removeEventListener('unhandledrejection', handleUnhandledRejection);
    };
  }, []);

  return null;
};
```

## 📋 実装チェックリスト

### Phase 1: 緊急対応（即日）
- [ ] API ルート修正 (`src/app/api/admin/preset-products/[presetId]/route.ts`)
- [ ] 安全なレンダリング関数実装 (`src/lib/utils/safeRender.ts`)
- [ ] ProductSelectionSection の基本修正
- [ ] 本番環境でのAPI動作確認

### Phase 2: 安定化対応（1週間）
- [ ] ProductSelectionSection の完全リファクタリング
- [ ] useFormConfig フックの強化
- [ ] エラー境界コンポーネントの実装
- [ ] 詳細ログシステムの導入

### Phase 3: 監視・改善（1ヶ月）
- [ ] エラー監視システムの構築
- [ ] パフォーマンス監視の実装
- [ ] 自動テストの追加
- [ ] ドキュメントの整備

## 🚨 注意事項

### 実装時の重要ポイント
1. **型安全性**: 全ての外部データに対して型チェックを実施
2. **エラーハンドリング**: 各レベルでの適切なエラー処理
3. **ログ出力**: 問題特定のための詳細なログ
4. **フォールバック**: エラー時の代替表示

### デプロイ時の確認項目
1. **API エンドポイント**: 全てのルートが正常に動作するか
2. **環境変数**: 本番環境での設定が正しいか
3. **キャッシュ**: Vercel のキャッシュが適切にクリアされているか
4. **ログ**: エラーログが適切に出力されているか

---

**作成日**: 2025年8月5日  
**対象システム**: LINE予約システム（ベジライス）  
**対象バージョン**: Next.js 15.4.3  
**作成者**: Kiro AI Assistant