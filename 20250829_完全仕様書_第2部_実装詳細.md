# 商品予約システム完全仕様書 第2部 - 実装詳細

## 🔧 **技術実装仕様**

### **1. 技術スタック詳細**

#### **フロントエンド技術**
```json
{
  "framework": "Next.js 15.4.3",
  "router": "App Router",
  "react": "19.1.0",
  "typescript": "5.x",
  "styling": "Tailwind CSS 4.0",
  "ui_components": "Radix UI + Custom Components",
  "forms": "React Hook Form 7.61.0",
  "validation": "Zod 4.0.8",
  "state_management": "Zustand 5.0.6",
  "date_handling": "date-fns 4.1.0",
  "animations": "Framer Motion 12.23.7",
  "line_integration": "@line/liff 2.27.1"
}
```

#### **バックエンド技術**
```json
{
  "runtime": "Node.js (Next.js API Routes)",
  "database": "Supabase PostgreSQL",
  "orm": "Supabase Client",
  "authentication": "Custom Password Auth",
  "file_processing": "PapaParse 5.5.3",
  "csv_handling": "Built-in CSV Parser",
  "validation": "Zod Server-side",
  "error_handling": "Custom Error Classes",
  "logging": "Structured JSON Logging"
}
```

#### **外部サービス**
```json
{
  "database": "Supabase (PostgreSQL + Auth + Storage)",
  "line_platform": "LINE Messaging API + LIFF",
  "deployment": "Vercel (推奨)",
  "monitoring": "Built-in + External (Sentry推奨)",
  "cdn": "Vercel Edge Network"
}
```

### **2. コンポーネント設計**

#### **アトミックデザイン構造**
```
src/components/
├── ui/                     # Atoms（最小単位）
│   ├── Button/
│   │   ├── Button.tsx
│   │   ├── Button.test.tsx
│   │   └── index.ts
│   ├── Input/
│   ├── LoadingSpinner/
│   ├── ErrorMessage/
│   └── FormField/
├── common/                 # Molecules（組み合わせ）
│   ├── Pagination.tsx
│   ├── ErrorBoundary.tsx
│   ├── LazyLoadComponent.tsx
│   └── ProductErrorBoundary.tsx
├── features/               # Organisms（機能単位）
│   ├── reservation/
│   │   ├── UserInfoSection.tsx
│   │   ├── ProductSelectionSection.tsx
│   │   └── PickupDateSection.tsx
│   └── index.ts
├── forms/                  # Templates（画面テンプレート）
│   ├── ReservationForm.tsx
│   ├── ProductSelection.tsx
│   └── PickupDateCalendar.tsx
├── admin/                  # Admin Pages（管理画面）
│   ├── AdminLayout.tsx
│   ├── AdminAuthWrapper.tsx
│   ├── AdminSidebar.tsx
│   └── products/
│       ├── ProductsContainer.tsx
│       ├── ProductTable.tsx
│       ├── ProductFilters.tsx
│       ├── ProductEditModal.tsx
│       ├── ProductDeleteModal.tsx
│       └── ProductImportModal.tsx
└── line/                   # LINE Integration
    └── LiffProvider.tsx
```

#### **コンポーネント実装例**
```typescript
// src/components/ui/Button/Button.tsx
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'danger' | 'ghost';
  size?: 'sm' | 'md' | 'lg';
  loading?: boolean;
  icon?: React.ReactNode;
}

export const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'md',
  loading = false,
  icon,
  children,
  className,
  disabled,
  ...props
}) => {
  const baseClasses = 'inline-flex items-center justify-center font-medium rounded-md transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2';
  
  const variantClasses = {
    primary: 'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500',
    secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300 focus:ring-gray-500',
    danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500',
    ghost: 'text-gray-700 hover:bg-gray-100 focus:ring-gray-500'
  };
  
  const sizeClasses = {
    sm: 'px-3 py-2 text-sm',
    md: 'px-4 py-2 text-base',
    lg: 'px-6 py-3 text-lg'
  };
  
  return (
    <button
      className={cn(
        baseClasses,
        variantClasses[variant],
        sizeClasses[size],
        (disabled || loading) && 'opacity-50 cursor-not-allowed',
        className
      )}
      disabled={disabled || loading}
      {...props}
    >
      {loading && <LoadingSpinner size="sm" className="mr-2" />}
      {icon && !loading && <span className="mr-2">{icon}</span>}
      {children}
    </button>
  );
};
```

### **3. 状態管理設計**

#### **Zustand Store構造**
```typescript
// src/stores/reservationStore.ts
interface ReservationStore {
  // 状態
  formData: ReservationFormData | null;
  selectedProducts: SelectedProduct[];
  currentStep: 'input' | 'confirm' | 'complete';
  isSubmitting: boolean;
  error: string | null;
  
  // アクション
  setFormData: (data: ReservationFormData) => void;
  addProduct: (product: SelectedProduct) => void;
  removeProduct: (productId: number) => void;
  updateProductQuantity: (productId: number, quantity: number) => void;
  setCurrentStep: (step: 'input' | 'confirm' | 'complete') => void;
  setSubmitting: (isSubmitting: boolean) => void;
  setError: (error: string | null) => void;
  resetForm: () => void;
  
  // 計算プロパティ
  getTotalAmount: () => number;
  getProductCount: () => number;
  isFormValid: () => boolean;
}

export const useReservationStore = create<ReservationStore>((set, get) => ({
  // 初期状態
  formData: null,
  selectedProducts: [],
  currentStep: 'input',
  isSubmitting: false,
  error: null,
  
  // アクション実装
  setFormData: (data) => set({ formData: data }),
  
  addProduct: (product) => set((state) => ({
    selectedProducts: [...state.selectedProducts, product]
  })),
  
  removeProduct: (productId) => set((state) => ({
    selectedProducts: state.selectedProducts.filter(p => p.product_id !== productId)
  })),
  
  updateProductQuantity: (productId, quantity) => set((state) => ({
    selectedProducts: state.selectedProducts.map(p =>
      p.product_id === productId
        ? { ...p, quantity, total_price: p.unit_price * quantity }
        : p
    )
  })),
  
  setCurrentStep: (step) => set({ currentStep: step }),
  setSubmitting: (isSubmitting) => set({ isSubmitting }),
  setError: (error) => set({ error }),
  
  resetForm: () => set({
    formData: null,
    selectedProducts: [],
    currentStep: 'input',
    isSubmitting: false,
    error: null
  }),
  
  // 計算プロパティ
  getTotalAmount: () => {
    const { selectedProducts } = get();
    return selectedProducts.reduce((sum, product) => sum + product.total_price, 0);
  },
  
  getProductCount: () => {
    const { selectedProducts } = get();
    return selectedProducts.reduce((sum, product) => sum + product.quantity, 0);
  },
  
  isFormValid: () => {
    const { formData, selectedProducts } = get();
    return !!(formData && selectedProducts.length > 0);
  }
}));
```

### **4. カスタムフック設計**

#### **useFormConfig Hook**
```typescript
// src/hooks/useFormConfig.ts
interface UseFormConfigReturn {
  config: FormConfigResponse | null;
  loading: boolean;
  error: string | null;
  refetch: () => Promise<void>;
}

export const useFormConfig = (presetId: number): UseFormConfigReturn => {
  const [config, setConfig] = useState<FormConfigResponse | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const fetchConfig = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch(`/api/presets/${presetId}/config`);
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'フォーム設定の取得に失敗しました');
      }
      
      const result = await response.json();
      
      if (!result.success || !result.data) {
        throw new Error('フォーム設定の取得に失敗しました');
      }
      
      setConfig(result.data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'エラーが発生しました');
    } finally {
      setLoading(false);
    }
  }, [presetId]);
  
  useEffect(() => {
    if (presetId > 0) {
      fetchConfig();
    }
  }, [presetId, fetchConfig]);
  
  return {
    config,
    loading,
    error,
    refetch: fetchConfig
  };
};
```

#### **useReservationForm Hook**
```typescript
// src/hooks/useReservationForm.ts
interface UseReservationFormProps {
  formSettings?: FormSettings;
  defaultValues?: Partial<ReservationFormData>;
}

interface UseReservationFormReturn {
  methods: UseFormReturn<ReservationFormData>;
  selectedProducts: SelectedProduct[];
  addProduct: (product: SelectedProduct) => void;
  removeProduct: (productId: number) => void;
  updateQuantity: (productId: number, quantity: number) => void;
  getTotalAmount: () => number;
}

export const useReservationForm = ({
  formSettings,
  defaultValues = {}
}: UseReservationFormProps): UseReservationFormReturn => {
  
  // 動的バリデーションスキーマ生成
  const validationSchema = useMemo(() => {
    if (!formSettings) return reservationFormSchema;
    return createConditionalSchema(formSettings);
  }, [formSettings]);
  
  // React Hook Form初期化
  const methods = useForm<ReservationFormData>({
    resolver: zodResolver(validationSchema),
    defaultValues: {
      user_name: '',
      furigana: '',
      phone_number: '',
      products: [],
      pickup_dates: {},
      note: '',
      ...defaultValues
    },
    mode: 'onChange'
  });
  
  // 商品選択状態管理
  const [selectedProducts, setSelectedProducts] = useState<SelectedProduct[]>([]);
  
  // 商品追加
  const addProduct = useCallback((product: SelectedProduct) => {
    setSelectedProducts(prev => {
      const existing = prev.find(p => p.product_id === product.product_id);
      if (existing) {
        return prev.map(p =>
          p.product_id === product.product_id
            ? { ...p, quantity: p.quantity + product.quantity }
            : p
        );
      }
      return [...prev, product];
    });
    
    // フォームの products フィールドも更新
    const currentProducts = methods.getValues('products');
    methods.setValue('products', [...currentProducts, product]);
  }, [methods]);
  
  // 商品削除
  const removeProduct = useCallback((productId: number) => {
    setSelectedProducts(prev => prev.filter(p => p.product_id !== productId));
    
    const currentProducts = methods.getValues('products');
    methods.setValue('products', currentProducts.filter(p => p.product_id !== productId));
  }, [methods]);
  
  // 数量更新
  const updateQuantity = useCallback((productId: number, quantity: number) => {
    setSelectedProducts(prev => prev.map(p =>
      p.product_id === productId
        ? { ...p, quantity, total_price: p.unit_price * quantity }
        : p
    ));
    
    const currentProducts = methods.getValues('products');
    methods.setValue('products', currentProducts.map(p =>
      p.product_id === productId
        ? { ...p, quantity, total_price: p.unit_price * quantity }
        : p
    ));
  }, [methods]);
  
  // 合計金額計算
  const getTotalAmount = useCallback(() => {
    return selectedProducts.reduce((sum, product) => sum + product.total_price, 0);
  }, [selectedProducts]);
  
  return {
    methods,
    selectedProducts,
    addProduct,
    removeProduct,
    updateQuantity,
    getTotalAmount
  };
};
```